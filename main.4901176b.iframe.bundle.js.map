{"version":3,"file":"main.4901176b.iframe.bundle.js","mappings":";;AAuPA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;;AAEA;;;AAGA;AACA;;;AAMA;ACiyBA;AACA;AACA;;;AAGA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;AAGA;;;AAGA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;;;AAOA;AAzOA;AACA;AACA;ACpfA;AAGA;AC7LA;;;;;;;;;;;AAYA","sources":["webpack://@uswds/uswds/./packages/usa-combo-box/src/index.js","webpack://@uswds/uswds/./packages/usa-date-picker/src/index.js","webpack://@uswds/uswds/./packages/usa-file-input/src/index.js","webpack://@uswds/uswds/./packages/usa-table/src/index.js"],"sourcesContent":["const keymap = require(\"receptor/keymap\");\nconst selectOrMatches = require(\"../../uswds-core/src/js/utils/select-or-matches\");\nconst behavior = require(\"../../uswds-core/src/js/utils/behavior\");\nconst Sanitizer = require(\"../../uswds-core/src/js/utils/sanitizer\");\nconst { prefix: PREFIX } = require(\"../../uswds-core/src/js/config\");\nconst { CLICK } = require(\"../../uswds-core/src/js/events\");\n\nconst COMBO_BOX_CLASS = `${PREFIX}-combo-box`;\nconst COMBO_BOX_PRISTINE_CLASS = `${COMBO_BOX_CLASS}--pristine`;\nconst SELECT_CLASS = `${COMBO_BOX_CLASS}__select`;\nconst INPUT_CLASS = `${COMBO_BOX_CLASS}__input`;\nconst CLEAR_INPUT_BUTTON_CLASS = `${COMBO_BOX_CLASS}__clear-input`;\nconst CLEAR_INPUT_BUTTON_WRAPPER_CLASS = `${CLEAR_INPUT_BUTTON_CLASS}__wrapper`;\nconst INPUT_BUTTON_SEPARATOR_CLASS = `${COMBO_BOX_CLASS}__input-button-separator`;\nconst TOGGLE_LIST_BUTTON_CLASS = `${COMBO_BOX_CLASS}__toggle-list`;\nconst TOGGLE_LIST_BUTTON_WRAPPER_CLASS = `${TOGGLE_LIST_BUTTON_CLASS}__wrapper`;\nconst LIST_CLASS = `${COMBO_BOX_CLASS}__list`;\nconst LIST_OPTION_CLASS = `${COMBO_BOX_CLASS}__list-option`;\nconst LIST_OPTION_FOCUSED_CLASS = `${LIST_OPTION_CLASS}--focused`;\nconst LIST_OPTION_SELECTED_CLASS = `${LIST_OPTION_CLASS}--selected`;\nconst STATUS_CLASS = `${COMBO_BOX_CLASS}__status`;\n\nconst COMBO_BOX = `.${COMBO_BOX_CLASS}`;\nconst SELECT = `.${SELECT_CLASS}`;\nconst INPUT = `.${INPUT_CLASS}`;\nconst CLEAR_INPUT_BUTTON = `.${CLEAR_INPUT_BUTTON_CLASS}`;\nconst TOGGLE_LIST_BUTTON = `.${TOGGLE_LIST_BUTTON_CLASS}`;\nconst LIST = `.${LIST_CLASS}`;\nconst LIST_OPTION = `.${LIST_OPTION_CLASS}`;\nconst LIST_OPTION_FOCUSED = `.${LIST_OPTION_FOCUSED_CLASS}`;\nconst LIST_OPTION_SELECTED = `.${LIST_OPTION_SELECTED_CLASS}`;\nconst STATUS = `.${STATUS_CLASS}`;\n\nconst DEFAULT_FILTER = \".*{{query}}.*\";\n\nconst noop = () => {};\n\n/**\n * set the value of the element and dispatch a change event\n *\n * @param {HTMLInputElement|HTMLSelectElement} el The element to update\n * @param {string} value The new value of the element\n */\nconst changeElementValue = (el, value = \"\") => {\n  const elementToChange = el;\n  elementToChange.value = value;\n\n  const event = new CustomEvent(\"change\", {\n    bubbles: true,\n    cancelable: true,\n    detail: { value },\n  });\n  elementToChange.dispatchEvent(event);\n};\n\n/**\n * The elements within the combo box.\n * @typedef {Object} ComboBoxContext\n * @property {HTMLElement} comboBoxEl\n * @property {HTMLSelectElement} selectEl\n * @property {HTMLInputElement} inputEl\n * @property {HTMLUListElement} listEl\n * @property {HTMLDivElement} statusEl\n * @property {HTMLLIElement} focusedOptionEl\n * @property {HTMLLIElement} selectedOptionEl\n * @property {HTMLButtonElement} toggleListBtnEl\n * @property {HTMLButtonElement} clearInputBtnEl\n * @property {boolean} isPristine\n * @property {boolean} disableFiltering\n */\n\n/**\n * Get an object of elements belonging directly to the given\n * combo box component.\n *\n * @param {HTMLElement} el the element within the combo box\n * @returns {ComboBoxContext} elements\n */\nconst getComboBoxContext = (el) => {\n  const comboBoxEl = el.closest(COMBO_BOX);\n\n  if (!comboBoxEl) {\n    throw new Error(`Element is missing outer ${COMBO_BOX}`);\n  }\n\n  const selectEl = comboBoxEl.querySelector(SELECT);\n  const inputEl = comboBoxEl.querySelector(INPUT);\n  const listEl = comboBoxEl.querySelector(LIST);\n  const statusEl = comboBoxEl.querySelector(STATUS);\n  const focusedOptionEl = comboBoxEl.querySelector(LIST_OPTION_FOCUSED);\n  const selectedOptionEl = comboBoxEl.querySelector(LIST_OPTION_SELECTED);\n  const toggleListBtnEl = comboBoxEl.querySelector(TOGGLE_LIST_BUTTON);\n  const clearInputBtnEl = comboBoxEl.querySelector(CLEAR_INPUT_BUTTON);\n\n  const isPristine = comboBoxEl.classList.contains(COMBO_BOX_PRISTINE_CLASS);\n  const disableFiltering = comboBoxEl.dataset.disableFiltering === \"true\";\n\n  return {\n    comboBoxEl,\n    selectEl,\n    inputEl,\n    listEl,\n    statusEl,\n    focusedOptionEl,\n    selectedOptionEl,\n    toggleListBtnEl,\n    clearInputBtnEl,\n    isPristine,\n    disableFiltering,\n  };\n};\n\n/**\n * Disable the combo-box component\n *\n * @param {HTMLInputElement} el An element within the combo box component\n */\nconst disable = (el) => {\n  const { inputEl, toggleListBtnEl, clearInputBtnEl } = getComboBoxContext(el);\n\n  clearInputBtnEl.hidden = true;\n  clearInputBtnEl.disabled = true;\n  toggleListBtnEl.disabled = true;\n  inputEl.disabled = true;\n};\n\n/**\n * Check for aria-disabled on initialization\n *\n * @param {HTMLInputElement} el An element within the combo box component\n */\nconst ariaDisable = (el) => {\n  const { inputEl, toggleListBtnEl, clearInputBtnEl } = getComboBoxContext(el);\n\n  clearInputBtnEl.hidden = true;\n  clearInputBtnEl.setAttribute(\"aria-disabled\", true);\n  toggleListBtnEl.setAttribute(\"aria-disabled\", true);\n  inputEl.setAttribute(\"aria-disabled\", true);\n};\n\n/**\n * Enable the combo-box component\n *\n * @param {HTMLInputElement} el An element within the combo box component\n */\nconst enable = (el) => {\n  const { inputEl, toggleListBtnEl, clearInputBtnEl } = getComboBoxContext(el);\n\n  clearInputBtnEl.hidden = false;\n  clearInputBtnEl.disabled = false;\n  toggleListBtnEl.disabled = false;\n  inputEl.disabled = false;\n};\n\n/**\n * Enhance a select element into a combo box component.\n *\n * @param {HTMLElement} _comboBoxEl The initial element of the combo box component\n */\nconst enhanceComboBox = (_comboBoxEl) => {\n  const comboBoxEl = _comboBoxEl.closest(COMBO_BOX);\n\n  if (comboBoxEl.dataset.enhanced) return;\n\n  const selectEl = comboBoxEl.querySelector(\"select\");\n\n  if (!selectEl) {\n    throw new Error(`${COMBO_BOX} is missing inner select`);\n  }\n\n  const selectId = selectEl.id;\n  const selectLabel = document.querySelector(`label[for=\"${selectId}\"]`);\n  const listId = `${selectId}--list`;\n  const listIdLabel = `${selectId}-label`;\n  const assistiveHintID = `${selectId}--assistiveHint`;\n  const additionalAttributes = [];\n  const { defaultValue } = comboBoxEl.dataset;\n  const { placeholder } = comboBoxEl.dataset;\n  let selectedOption;\n\n  if (placeholder) {\n    additionalAttributes.push({ placeholder });\n  }\n\n  if (defaultValue) {\n    for (let i = 0, len = selectEl.options.length; i < len; i += 1) {\n      const optionEl = selectEl.options[i];\n\n      if (optionEl.value === defaultValue) {\n        selectedOption = optionEl;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Throw error if combobox is missing a label or label is missing\n   * `for` attribute. Otherwise, set the ID to match the <ul> aria-labelledby\n   */\n  if (!selectLabel || !selectLabel.matches(`label[for=\"${selectId}\"]`)) {\n    throw new Error(\n      `${COMBO_BOX} for ${selectId} is either missing a label or a \"for\" attribute`\n    );\n  } else {\n    selectLabel.setAttribute(\"id\", listIdLabel);\n  }\n\n  selectLabel.setAttribute(\"id\", listIdLabel);\n  selectEl.setAttribute(\"aria-hidden\", \"true\");\n  selectEl.setAttribute(\"tabindex\", \"-1\");\n  selectEl.classList.add(\"usa-sr-only\", SELECT_CLASS);\n  selectEl.id = \"\";\n  selectEl.value = \"\";\n\n  [\"required\", \"aria-label\", \"aria-labelledby\"].forEach((name) => {\n    if (selectEl.hasAttribute(name)) {\n      const value = selectEl.getAttribute(name);\n      additionalAttributes.push({ [name]: value });\n      selectEl.removeAttribute(name);\n    }\n  });\n\n  // sanitize doesn't like functions in template literals\n  const input = document.createElement(\"input\");\n  input.setAttribute(\"id\", selectId);\n  input.setAttribute(\"aria-owns\", listId);\n  input.setAttribute(\"aria-controls\", listId);\n  input.setAttribute(\"aria-autocomplete\", \"list\");\n  input.setAttribute(\"aria-describedby\", assistiveHintID);\n  input.setAttribute(\"aria-expanded\", \"false\");\n  input.setAttribute(\"autocapitalize\", \"off\");\n  input.setAttribute(\"autocomplete\", \"off\");\n  input.setAttribute(\"class\", INPUT_CLASS);\n  input.setAttribute(\"type\", \"text\");\n  input.setAttribute(\"role\", \"combobox\");\n  additionalAttributes.forEach((attr) =>\n    Object.keys(attr).forEach((key) => {\n      const value = Sanitizer.escapeHTML`${attr[key]}`;\n      input.setAttribute(key, value);\n    })\n  );\n\n  comboBoxEl.insertAdjacentElement(\"beforeend\", input);\n\n  comboBoxEl.insertAdjacentHTML(\n    \"beforeend\",\n    Sanitizer.escapeHTML`\n    <span class=\"${CLEAR_INPUT_BUTTON_WRAPPER_CLASS}\" tabindex=\"-1\">\n        <button type=\"button\" class=\"${CLEAR_INPUT_BUTTON_CLASS}\" aria-label=\"Clear the select contents\">&nbsp;</button>\n      </span>\n      <span class=\"${INPUT_BUTTON_SEPARATOR_CLASS}\">&nbsp;</span>\n      <span class=\"${TOGGLE_LIST_BUTTON_WRAPPER_CLASS}\" tabindex=\"-1\">\n        <button type=\"button\" tabindex=\"-1\" class=\"${TOGGLE_LIST_BUTTON_CLASS}\" aria-label=\"Toggle the dropdown list\">&nbsp;</button>\n      </span>\n      <ul\n        tabindex=\"-1\"\n        id=\"${listId}\"\n        class=\"${LIST_CLASS}\"\n        role=\"listbox\"\n        aria-labelledby=\"${listIdLabel}\"\n        hidden>\n      </ul>\n      <div class=\"${STATUS_CLASS} usa-sr-only\" role=\"status\"></div>\n      <span id=\"${assistiveHintID}\" class=\"usa-sr-only\">\n        When autocomplete results are available use up and down arrows to review and enter to select.\n        Touch device users, explore by touch or with swipe gestures.\n      </span>`\n  );\n\n  if (selectedOption) {\n    const { inputEl } = getComboBoxContext(comboBoxEl);\n    changeElementValue(selectEl, selectedOption.value);\n    changeElementValue(inputEl, selectedOption.text);\n    comboBoxEl.classList.add(COMBO_BOX_PRISTINE_CLASS);\n  }\n\n  if (selectEl.disabled) {\n    disable(comboBoxEl);\n    selectEl.disabled = false;\n  }\n\n  if (selectEl.hasAttribute(\"aria-disabled\")) {\n    ariaDisable(comboBoxEl);\n    selectEl.removeAttribute(\"aria-disabled\");\n  }\n\n  comboBoxEl.dataset.enhanced = \"true\";\n};\n\n/**\n * Manage the focused element within the list options when\n * navigating via keyboard.\n *\n * @param {HTMLElement} el An anchor element within the combo box component\n * @param {HTMLElement} nextEl An element within the combo box component\n * @param {Object} options options\n * @param {boolean} options.skipFocus skip focus of highlighted item\n * @param {boolean} options.preventScroll should skip procedure to scroll to element\n */\nconst highlightOption = (el, nextEl, { skipFocus, preventScroll } = {}) => {\n  const { inputEl, listEl, focusedOptionEl } = getComboBoxContext(el);\n\n  if (focusedOptionEl) {\n    focusedOptionEl.classList.remove(LIST_OPTION_FOCUSED_CLASS);\n    focusedOptionEl.setAttribute(\"tabIndex\", \"-1\");\n  }\n\n  if (nextEl) {\n    inputEl.setAttribute(\"aria-activedescendant\", nextEl.id);\n    nextEl.setAttribute(\"tabIndex\", \"0\");\n    nextEl.classList.add(LIST_OPTION_FOCUSED_CLASS);\n\n    if (!preventScroll) {\n      const optionBottom = nextEl.offsetTop + nextEl.offsetHeight;\n      const currentBottom = listEl.scrollTop + listEl.offsetHeight;\n\n      if (optionBottom > currentBottom) {\n        listEl.scrollTop = optionBottom - listEl.offsetHeight;\n      }\n\n      if (nextEl.offsetTop < listEl.scrollTop) {\n        listEl.scrollTop = nextEl.offsetTop;\n      }\n    }\n\n    if (!skipFocus) {\n      nextEl.focus({ preventScroll });\n    }\n  } else {\n    inputEl.setAttribute(\"aria-activedescendant\", \"\");\n    inputEl.focus();\n  }\n};\n\n/**\n * Generate a dynamic regular expression based off of a replaceable and possibly filtered value.\n *\n * @param {string} el An element within the combo box component\n * @param {string} query The value to use in the regular expression\n * @param {object} extras An object of regular expressions to replace and filter the query\n */\nconst generateDynamicRegExp = (filter, query = \"\", extras = {}) => {\n  const escapeRegExp = (text) =>\n    text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n\n  let find = filter.replace(/{{(.*?)}}/g, (m, $1) => {\n    const key = $1.trim();\n    const queryFilter = extras[key];\n    if (key !== \"query\" && queryFilter) {\n      const matcher = new RegExp(queryFilter, \"i\");\n      const matches = query.match(matcher);\n\n      if (matches) {\n        return escapeRegExp(matches[1]);\n      }\n\n      return \"\";\n    }\n    return escapeRegExp(query);\n  });\n\n  find = `^(?:${find})$`;\n\n  return new RegExp(find, \"i\");\n};\n\n/**\n * Display the option list of a combo box component.\n *\n * @param {HTMLElement} el An element within the combo box component\n */\nconst displayList = (el) => {\n  const {\n    comboBoxEl,\n    selectEl,\n    inputEl,\n    listEl,\n    statusEl,\n    isPristine,\n    disableFiltering,\n  } = getComboBoxContext(el);\n  let selectedItemId;\n  let firstFoundId;\n\n  const listOptionBaseId = `${listEl.id}--option-`;\n\n  const inputValue = (inputEl.value || \"\").toLowerCase();\n  const filter = comboBoxEl.dataset.filter || DEFAULT_FILTER;\n  const regex = generateDynamicRegExp(filter, inputValue, comboBoxEl.dataset);\n\n  const options = [];\n  for (let i = 0, len = selectEl.options.length; i < len; i += 1) {\n    const optionEl = selectEl.options[i];\n    const optionId = `${listOptionBaseId}${options.length}`;\n\n    if (\n      optionEl.value &&\n      (disableFiltering ||\n        isPristine ||\n        !inputValue ||\n        regex.test(optionEl.text))\n    ) {\n      if (selectEl.value && optionEl.value === selectEl.value) {\n        selectedItemId = optionId;\n      }\n\n      if (disableFiltering && !firstFoundId && regex.test(optionEl.text)) {\n        firstFoundId = optionId;\n      }\n      options.push(optionEl);\n    }\n  }\n\n  const numOptions = options.length;\n  const optionHtml = options.map((option, index) => {\n    const optionId = `${listOptionBaseId}${index}`;\n    const classes = [LIST_OPTION_CLASS];\n    let tabindex = \"-1\";\n    let ariaSelected = \"false\";\n\n    if (optionId === selectedItemId) {\n      classes.push(LIST_OPTION_SELECTED_CLASS, LIST_OPTION_FOCUSED_CLASS);\n      tabindex = \"0\";\n      ariaSelected = \"true\";\n    }\n\n    if (!selectedItemId && index === 0) {\n      classes.push(LIST_OPTION_FOCUSED_CLASS);\n      tabindex = \"0\";\n    }\n\n    const li = document.createElement(\"li\");\n\n    li.setAttribute(\"aria-setsize\", options.length);\n    li.setAttribute(\"aria-posinset\", index + 1);\n    li.setAttribute(\"aria-selected\", ariaSelected);\n    li.setAttribute(\"id\", optionId);\n    li.setAttribute(\"class\", classes.join(\" \"));\n    li.setAttribute(\"tabindex\", tabindex);\n    li.setAttribute(\"role\", \"option\");\n    li.setAttribute(\"data-value\", option.value);\n    li.textContent = option.text;\n\n    return li;\n  });\n\n  const noResults = document.createElement(\"li\");\n  noResults.setAttribute(\"class\", `${LIST_OPTION_CLASS}--no-results`);\n  noResults.textContent = \"No results found\";\n\n  listEl.hidden = false;\n\n  if (numOptions) {\n    listEl.innerHTML = \"\";\n    optionHtml.forEach((item) =>\n      listEl.insertAdjacentElement(\"beforeend\", item)\n    );\n  } else {\n    listEl.innerHTML = \"\";\n    listEl.insertAdjacentElement(\"beforeend\", noResults);\n  }\n\n  inputEl.setAttribute(\"aria-expanded\", \"true\");\n\n  statusEl.textContent = numOptions\n    ? `${numOptions} result${numOptions > 1 ? \"s\" : \"\"} available.`\n    : \"No results.\";\n\n  let itemToFocus;\n\n  if (isPristine && selectedItemId) {\n    itemToFocus = listEl.querySelector(`#${selectedItemId}`);\n  } else if (disableFiltering && firstFoundId) {\n    itemToFocus = listEl.querySelector(`#${firstFoundId}`);\n  }\n\n  if (itemToFocus) {\n    highlightOption(listEl, itemToFocus, {\n      skipFocus: true,\n    });\n  }\n};\n\n/**\n * Hide the option list of a combo box component.\n *\n * @param {HTMLElement} el An element within the combo box component\n */\nconst hideList = (el) => {\n  const { inputEl, listEl, statusEl, focusedOptionEl } = getComboBoxContext(el);\n\n  statusEl.innerHTML = \"\";\n\n  inputEl.setAttribute(\"aria-expanded\", \"false\");\n  inputEl.setAttribute(\"aria-activedescendant\", \"\");\n\n  if (focusedOptionEl) {\n    focusedOptionEl.classList.remove(LIST_OPTION_FOCUSED_CLASS);\n  }\n\n  listEl.scrollTop = 0;\n  listEl.hidden = true;\n};\n\n/**\n * Select an option list of the combo box component.\n *\n * @param {HTMLElement} listOptionEl The list option being selected\n */\nconst selectItem = (listOptionEl) => {\n  const { comboBoxEl, selectEl, inputEl } = getComboBoxContext(listOptionEl);\n\n  changeElementValue(selectEl, listOptionEl.dataset.value);\n  changeElementValue(inputEl, listOptionEl.textContent);\n  comboBoxEl.classList.add(COMBO_BOX_PRISTINE_CLASS);\n  hideList(comboBoxEl);\n  inputEl.focus();\n};\n\n/**\n * Clear the input of the combo box\n *\n * @param {HTMLButtonElement} clearButtonEl The clear input button\n */\nconst clearInput = (clearButtonEl) => {\n  const { comboBoxEl, listEl, selectEl, inputEl } =\n    getComboBoxContext(clearButtonEl);\n  const listShown = !listEl.hidden;\n\n  if (selectEl.value) changeElementValue(selectEl);\n  if (inputEl.value) changeElementValue(inputEl);\n  comboBoxEl.classList.remove(COMBO_BOX_PRISTINE_CLASS);\n\n  if (listShown) displayList(comboBoxEl);\n  inputEl.focus();\n};\n\n/**\n * Reset the select based off of currently set select value\n *\n * @param {HTMLElement} el An element within the combo box component\n */\nconst resetSelection = (el) => {\n  const { comboBoxEl, selectEl, inputEl } = getComboBoxContext(el);\n\n  const selectValue = selectEl.value;\n  const inputValue = (inputEl.value || \"\").toLowerCase();\n\n  if (selectValue) {\n    for (let i = 0, len = selectEl.options.length; i < len; i += 1) {\n      const optionEl = selectEl.options[i];\n      if (optionEl.value === selectValue) {\n        if (inputValue !== optionEl.text) {\n          changeElementValue(inputEl, optionEl.text);\n        }\n        comboBoxEl.classList.add(COMBO_BOX_PRISTINE_CLASS);\n        return;\n      }\n    }\n  }\n\n  if (inputValue) {\n    changeElementValue(inputEl);\n  }\n};\n\n/**\n * Select an option list of the combo box component based off of\n * having a current focused list option or\n * having test that completely matches a list option.\n * Otherwise it clears the input and select.\n *\n * @param {HTMLElement} el An element within the combo box component\n */\nconst completeSelection = (el) => {\n  const { comboBoxEl, selectEl, inputEl, statusEl } = getComboBoxContext(el);\n\n  statusEl.textContent = \"\";\n\n  const inputValue = (inputEl.value || \"\").toLowerCase();\n\n  if (inputValue) {\n    for (let i = 0, len = selectEl.options.length; i < len; i += 1) {\n      const optionEl = selectEl.options[i];\n      if (optionEl.text.toLowerCase() === inputValue) {\n        changeElementValue(selectEl, optionEl.value);\n        changeElementValue(inputEl, optionEl.text);\n        comboBoxEl.classList.add(COMBO_BOX_PRISTINE_CLASS);\n        return;\n      }\n    }\n  }\n\n  resetSelection(comboBoxEl);\n};\n\n/**\n * Handle the escape event within the combo box component.\n *\n * @param {KeyboardEvent} event An event within the combo box component\n */\nconst handleEscape = (event) => {\n  const { comboBoxEl, inputEl } = getComboBoxContext(event.target);\n\n  hideList(comboBoxEl);\n  resetSelection(comboBoxEl);\n  inputEl.focus();\n};\n\n/**\n * Handle the down event within the combo box component.\n *\n * @param {KeyboardEvent} event An event within the combo box component\n */\nconst handleDownFromInput = (event) => {\n  const { comboBoxEl, listEl } = getComboBoxContext(event.target);\n\n  if (listEl.hidden) {\n    displayList(comboBoxEl);\n  }\n\n  const nextOptionEl =\n    listEl.querySelector(LIST_OPTION_FOCUSED) ||\n    listEl.querySelector(LIST_OPTION);\n\n  if (nextOptionEl) {\n    highlightOption(comboBoxEl, nextOptionEl);\n  }\n\n  event.preventDefault();\n};\n\n/**\n * Handle the enter event from an input element within the combo box component.\n *\n * @param {KeyboardEvent} event An event within the combo box component\n */\nconst handleEnterFromInput = (event) => {\n  const { comboBoxEl, listEl } = getComboBoxContext(event.target);\n  const listShown = !listEl.hidden;\n\n  completeSelection(comboBoxEl);\n\n  if (listShown) {\n    hideList(comboBoxEl);\n  }\n\n  event.preventDefault();\n};\n\n/**\n * Handle the down event within the combo box component.\n *\n * @param {KeyboardEvent} event An event within the combo box component\n */\nconst handleDownFromListOption = (event) => {\n  const focusedOptionEl = event.target;\n  const nextOptionEl = focusedOptionEl.nextSibling;\n\n  if (nextOptionEl) {\n    highlightOption(focusedOptionEl, nextOptionEl);\n  }\n\n  event.preventDefault();\n};\n\n/**\n * Handle the space event from an list option element within the combo box component.\n *\n * @param {KeyboardEvent} event An event within the combo box component\n */\nconst handleSpaceFromListOption = (event) => {\n  selectItem(event.target);\n  event.preventDefault();\n};\n\n/**\n * Handle the enter event from list option within the combo box component.\n *\n * @param {KeyboardEvent} event An event within the combo box component\n */\nconst handleEnterFromListOption = (event) => {\n  selectItem(event.target);\n  event.preventDefault();\n};\n\n/**\n * Handle the up event from list option within the combo box component.\n *\n * @param {KeyboardEvent} event An event within the combo box component\n */\nconst handleUpFromListOption = (event) => {\n  const { comboBoxEl, listEl, focusedOptionEl } = getComboBoxContext(\n    event.target\n  );\n  const nextOptionEl = focusedOptionEl && focusedOptionEl.previousSibling;\n  const listShown = !listEl.hidden;\n\n  highlightOption(comboBoxEl, nextOptionEl);\n\n  if (listShown) {\n    event.preventDefault();\n  }\n\n  if (!nextOptionEl) {\n    hideList(comboBoxEl);\n  }\n};\n\n/**\n * Select list option on the mouseover event.\n *\n * @param {MouseEvent} event The mouseover event\n * @param {HTMLLIElement} listOptionEl An element within the combo box component\n */\nconst handleMouseover = (listOptionEl) => {\n  const isCurrentlyFocused = listOptionEl.classList.contains(\n    LIST_OPTION_FOCUSED_CLASS\n  );\n\n  if (isCurrentlyFocused) return;\n\n  highlightOption(listOptionEl, listOptionEl, {\n    preventScroll: true,\n  });\n};\n\n/**\n * Toggle the list when the button is clicked\n *\n * @param {HTMLElement} el An element within the combo box component\n */\nconst toggleList = (el) => {\n  const { comboBoxEl, listEl, inputEl } = getComboBoxContext(el);\n\n  if (listEl.hidden) {\n    displayList(comboBoxEl);\n  } else {\n    hideList(comboBoxEl);\n  }\n\n  inputEl.focus();\n};\n\n/**\n * Handle click from input\n *\n * @param {HTMLInputElement} el An element within the combo box component\n */\nconst handleClickFromInput = (el) => {\n  const { comboBoxEl, listEl } = getComboBoxContext(el);\n\n  if (listEl.hidden) {\n    displayList(comboBoxEl);\n  }\n};\n\nconst comboBox = behavior(\n  {\n    [CLICK]: {\n      [INPUT]() {\n        if (this.disabled) return;\n        handleClickFromInput(this);\n      },\n      [TOGGLE_LIST_BUTTON]() {\n        if (this.disabled) return;\n        toggleList(this);\n      },\n      [LIST_OPTION]() {\n        if (this.disabled) return;\n        selectItem(this);\n      },\n      [CLEAR_INPUT_BUTTON]() {\n        if (this.disabled) return;\n        clearInput(this);\n      },\n    },\n    focusout: {\n      [COMBO_BOX](event) {\n        if (!this.contains(event.relatedTarget)) {\n          resetSelection(this);\n          hideList(this);\n        }\n      },\n    },\n    keydown: {\n      [COMBO_BOX]: keymap({\n        Escape: handleEscape,\n      }),\n      [INPUT]: keymap({\n        Enter: handleEnterFromInput,\n        ArrowDown: handleDownFromInput,\n        Down: handleDownFromInput,\n      }),\n      [LIST_OPTION]: keymap({\n        ArrowUp: handleUpFromListOption,\n        Up: handleUpFromListOption,\n        ArrowDown: handleDownFromListOption,\n        Down: handleDownFromListOption,\n        Enter: handleEnterFromListOption,\n        \" \": handleSpaceFromListOption,\n        \"Shift+Tab\": noop,\n      }),\n    },\n    input: {\n      [INPUT]() {\n        const comboBoxEl = this.closest(COMBO_BOX);\n        comboBoxEl.classList.remove(COMBO_BOX_PRISTINE_CLASS);\n        displayList(this);\n      },\n    },\n    mouseover: {\n      [LIST_OPTION]() {\n        handleMouseover(this);\n      },\n    },\n  },\n  {\n    init(root) {\n      selectOrMatches(COMBO_BOX, root).forEach((comboBoxEl) => {\n        enhanceComboBox(comboBoxEl);\n      });\n    },\n    getComboBoxContext,\n    enhanceComboBox,\n    generateDynamicRegExp,\n    disable,\n    enable,\n    displayList,\n    hideList,\n    COMBO_BOX_CLASS,\n  }\n);\n\nmodule.exports = comboBox;\n","const keymap = require(\"receptor/keymap\");\nconst behavior = require(\"../../uswds-core/src/js/utils/behavior\");\nconst select = require(\"../../uswds-core/src/js/utils/select\");\nconst selectOrMatches = require(\"../../uswds-core/src/js/utils/select-or-matches\");\nconst { prefix: PREFIX } = require(\"../../uswds-core/src/js/config\");\nconst { CLICK } = require(\"../../uswds-core/src/js/events\");\nconst activeElement = require(\"../../uswds-core/src/js/utils/active-element\");\nconst isIosDevice = require(\"../../uswds-core/src/js/utils/is-ios-device\");\nconst Sanitizer = require(\"../../uswds-core/src/js/utils/sanitizer\");\n\nconst DATE_PICKER_CLASS = `${PREFIX}-date-picker`;\nconst DATE_PICKER_WRAPPER_CLASS = `${DATE_PICKER_CLASS}__wrapper`;\nconst DATE_PICKER_INITIALIZED_CLASS = `${DATE_PICKER_CLASS}--initialized`;\nconst DATE_PICKER_ACTIVE_CLASS = `${DATE_PICKER_CLASS}--active`;\nconst DATE_PICKER_INTERNAL_INPUT_CLASS = `${DATE_PICKER_CLASS}__internal-input`;\nconst DATE_PICKER_EXTERNAL_INPUT_CLASS = `${DATE_PICKER_CLASS}__external-input`;\nconst DATE_PICKER_BUTTON_CLASS = `${DATE_PICKER_CLASS}__button`;\nconst DATE_PICKER_CALENDAR_CLASS = `${DATE_PICKER_CLASS}__calendar`;\nconst DATE_PICKER_STATUS_CLASS = `${DATE_PICKER_CLASS}__status`;\nconst CALENDAR_DATE_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__date`;\n\nconst CALENDAR_DATE_FOCUSED_CLASS = `${CALENDAR_DATE_CLASS}--focused`;\nconst CALENDAR_DATE_SELECTED_CLASS = `${CALENDAR_DATE_CLASS}--selected`;\nconst CALENDAR_DATE_PREVIOUS_MONTH_CLASS = `${CALENDAR_DATE_CLASS}--previous-month`;\nconst CALENDAR_DATE_CURRENT_MONTH_CLASS = `${CALENDAR_DATE_CLASS}--current-month`;\nconst CALENDAR_DATE_NEXT_MONTH_CLASS = `${CALENDAR_DATE_CLASS}--next-month`;\nconst CALENDAR_DATE_RANGE_DATE_CLASS = `${CALENDAR_DATE_CLASS}--range-date`;\nconst CALENDAR_DATE_TODAY_CLASS = `${CALENDAR_DATE_CLASS}--today`;\nconst CALENDAR_DATE_RANGE_DATE_START_CLASS = `${CALENDAR_DATE_CLASS}--range-date-start`;\nconst CALENDAR_DATE_RANGE_DATE_END_CLASS = `${CALENDAR_DATE_CLASS}--range-date-end`;\nconst CALENDAR_DATE_WITHIN_RANGE_CLASS = `${CALENDAR_DATE_CLASS}--within-range`;\nconst CALENDAR_PREVIOUS_YEAR_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__previous-year`;\nconst CALENDAR_PREVIOUS_MONTH_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__previous-month`;\nconst CALENDAR_NEXT_YEAR_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__next-year`;\nconst CALENDAR_NEXT_MONTH_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__next-month`;\nconst CALENDAR_MONTH_SELECTION_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__month-selection`;\nconst CALENDAR_YEAR_SELECTION_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__year-selection`;\nconst CALENDAR_MONTH_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__month`;\nconst CALENDAR_MONTH_FOCUSED_CLASS = `${CALENDAR_MONTH_CLASS}--focused`;\nconst CALENDAR_MONTH_SELECTED_CLASS = `${CALENDAR_MONTH_CLASS}--selected`;\nconst CALENDAR_YEAR_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__year`;\nconst CALENDAR_YEAR_FOCUSED_CLASS = `${CALENDAR_YEAR_CLASS}--focused`;\nconst CALENDAR_YEAR_SELECTED_CLASS = `${CALENDAR_YEAR_CLASS}--selected`;\nconst CALENDAR_PREVIOUS_YEAR_CHUNK_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__previous-year-chunk`;\nconst CALENDAR_NEXT_YEAR_CHUNK_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__next-year-chunk`;\nconst CALENDAR_DATE_PICKER_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__date-picker`;\nconst CALENDAR_MONTH_PICKER_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__month-picker`;\nconst CALENDAR_YEAR_PICKER_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__year-picker`;\nconst CALENDAR_TABLE_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__table`;\nconst CALENDAR_ROW_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__row`;\nconst CALENDAR_CELL_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__cell`;\nconst CALENDAR_CELL_CENTER_ITEMS_CLASS = `${CALENDAR_CELL_CLASS}--center-items`;\nconst CALENDAR_MONTH_LABEL_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__month-label`;\nconst CALENDAR_DAY_OF_WEEK_CLASS = `${DATE_PICKER_CALENDAR_CLASS}__day-of-week`;\n\nconst DATE_PICKER = `.${DATE_PICKER_CLASS}`;\nconst DATE_PICKER_BUTTON = `.${DATE_PICKER_BUTTON_CLASS}`;\nconst DATE_PICKER_INTERNAL_INPUT = `.${DATE_PICKER_INTERNAL_INPUT_CLASS}`;\nconst DATE_PICKER_EXTERNAL_INPUT = `.${DATE_PICKER_EXTERNAL_INPUT_CLASS}`;\nconst DATE_PICKER_CALENDAR = `.${DATE_PICKER_CALENDAR_CLASS}`;\nconst DATE_PICKER_STATUS = `.${DATE_PICKER_STATUS_CLASS}`;\nconst CALENDAR_DATE = `.${CALENDAR_DATE_CLASS}`;\nconst CALENDAR_DATE_FOCUSED = `.${CALENDAR_DATE_FOCUSED_CLASS}`;\nconst CALENDAR_DATE_CURRENT_MONTH = `.${CALENDAR_DATE_CURRENT_MONTH_CLASS}`;\nconst CALENDAR_PREVIOUS_YEAR = `.${CALENDAR_PREVIOUS_YEAR_CLASS}`;\nconst CALENDAR_PREVIOUS_MONTH = `.${CALENDAR_PREVIOUS_MONTH_CLASS}`;\nconst CALENDAR_NEXT_YEAR = `.${CALENDAR_NEXT_YEAR_CLASS}`;\nconst CALENDAR_NEXT_MONTH = `.${CALENDAR_NEXT_MONTH_CLASS}`;\nconst CALENDAR_YEAR_SELECTION = `.${CALENDAR_YEAR_SELECTION_CLASS}`;\nconst CALENDAR_MONTH_SELECTION = `.${CALENDAR_MONTH_SELECTION_CLASS}`;\nconst CALENDAR_MONTH = `.${CALENDAR_MONTH_CLASS}`;\nconst CALENDAR_YEAR = `.${CALENDAR_YEAR_CLASS}`;\nconst CALENDAR_PREVIOUS_YEAR_CHUNK = `.${CALENDAR_PREVIOUS_YEAR_CHUNK_CLASS}`;\nconst CALENDAR_NEXT_YEAR_CHUNK = `.${CALENDAR_NEXT_YEAR_CHUNK_CLASS}`;\nconst CALENDAR_DATE_PICKER = `.${CALENDAR_DATE_PICKER_CLASS}`;\nconst CALENDAR_MONTH_PICKER = `.${CALENDAR_MONTH_PICKER_CLASS}`;\nconst CALENDAR_YEAR_PICKER = `.${CALENDAR_YEAR_PICKER_CLASS}`;\nconst CALENDAR_MONTH_FOCUSED = `.${CALENDAR_MONTH_FOCUSED_CLASS}`;\nconst CALENDAR_YEAR_FOCUSED = `.${CALENDAR_YEAR_FOCUSED_CLASS}`;\n\nconst VALIDATION_MESSAGE = \"Please enter a valid date\";\n\nconst MONTH_LABELS = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\",\n];\n\nconst DAY_OF_WEEK_LABELS = [\n  \"Sunday\",\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n];\n\nconst ENTER_KEYCODE = 13;\n\nconst YEAR_CHUNK = 12;\n\nconst DEFAULT_MIN_DATE = \"0000-01-01\";\nconst DEFAULT_EXTERNAL_DATE_FORMAT = \"MM/DD/YYYY\";\nconst INTERNAL_DATE_FORMAT = \"YYYY-MM-DD\";\n\nconst NOT_DISABLED_SELECTOR = \":not([disabled])\";\n\nconst processFocusableSelectors = (...selectors) =>\n  selectors.map((query) => query + NOT_DISABLED_SELECTOR).join(\", \");\n\nconst DATE_PICKER_FOCUSABLE = processFocusableSelectors(\n  CALENDAR_PREVIOUS_YEAR,\n  CALENDAR_PREVIOUS_MONTH,\n  CALENDAR_YEAR_SELECTION,\n  CALENDAR_MONTH_SELECTION,\n  CALENDAR_NEXT_YEAR,\n  CALENDAR_NEXT_MONTH,\n  CALENDAR_DATE_FOCUSED\n);\n\nconst MONTH_PICKER_FOCUSABLE = processFocusableSelectors(\n  CALENDAR_MONTH_FOCUSED\n);\n\nconst YEAR_PICKER_FOCUSABLE = processFocusableSelectors(\n  CALENDAR_PREVIOUS_YEAR_CHUNK,\n  CALENDAR_NEXT_YEAR_CHUNK,\n  CALENDAR_YEAR_FOCUSED\n);\n\n// #region Date Manipulation Functions\n\n/**\n * Keep date within month. Month would only be over by 1 to 3 days\n *\n * @param {Date} dateToCheck the date object to check\n * @param {number} month the correct month\n * @returns {Date} the date, corrected if needed\n */\nconst keepDateWithinMonth = (dateToCheck, month) => {\n  if (month !== dateToCheck.getMonth()) {\n    dateToCheck.setDate(0);\n  }\n\n  return dateToCheck;\n};\n\n/**\n * Set date from month day year\n *\n * @param {number} year the year to set\n * @param {number} month the month to set (zero-indexed)\n * @param {number} date the date to set\n * @returns {Date} the set date\n */\nconst setDate = (year, month, date) => {\n  const newDate = new Date(0);\n  newDate.setFullYear(year, month, date);\n  return newDate;\n};\n\n/**\n * todays date\n *\n * @returns {Date} todays date\n */\nconst today = () => {\n  const newDate = new Date();\n  const day = newDate.getDate();\n  const month = newDate.getMonth();\n  const year = newDate.getFullYear();\n  return setDate(year, month, day);\n};\n\n/**\n * Set date to first day of the month\n *\n * @param {number} date the date to adjust\n * @returns {Date} the adjusted date\n */\nconst startOfMonth = (date) => {\n  const newDate = new Date(0);\n  newDate.setFullYear(date.getFullYear(), date.getMonth(), 1);\n  return newDate;\n};\n\n/**\n * Set date to last day of the month\n *\n * @param {number} date the date to adjust\n * @returns {Date} the adjusted date\n */\nconst lastDayOfMonth = (date) => {\n  const newDate = new Date(0);\n  newDate.setFullYear(date.getFullYear(), date.getMonth() + 1, 0);\n  return newDate;\n};\n\n/**\n * Add days to date\n *\n * @param {Date} _date the date to adjust\n * @param {number} numDays the difference in days\n * @returns {Date} the adjusted date\n */\nconst addDays = (_date, numDays) => {\n  const newDate = new Date(_date.getTime());\n  newDate.setDate(newDate.getDate() + numDays);\n  return newDate;\n};\n\n/**\n * Subtract days from date\n *\n * @param {Date} _date the date to adjust\n * @param {number} numDays the difference in days\n * @returns {Date} the adjusted date\n */\nconst subDays = (_date, numDays) => addDays(_date, -numDays);\n\n/**\n * Add weeks to date\n *\n * @param {Date} _date the date to adjust\n * @param {number} numWeeks the difference in weeks\n * @returns {Date} the adjusted date\n */\nconst addWeeks = (_date, numWeeks) => addDays(_date, numWeeks * 7);\n\n/**\n * Subtract weeks from date\n *\n * @param {Date} _date the date to adjust\n * @param {number} numWeeks the difference in weeks\n * @returns {Date} the adjusted date\n */\nconst subWeeks = (_date, numWeeks) => addWeeks(_date, -numWeeks);\n\n/**\n * Set date to the start of the week (Sunday)\n *\n * @param {Date} _date the date to adjust\n * @returns {Date} the adjusted date\n */\nconst startOfWeek = (_date) => {\n  const dayOfWeek = _date.getDay();\n  return subDays(_date, dayOfWeek);\n};\n\n/**\n * Set date to the end of the week (Saturday)\n *\n * @param {Date} _date the date to adjust\n * @param {number} numWeeks the difference in weeks\n * @returns {Date} the adjusted date\n */\nconst endOfWeek = (_date) => {\n  const dayOfWeek = _date.getDay();\n  return addDays(_date, 6 - dayOfWeek);\n};\n\n/**\n * Add months to date and keep date within month\n *\n * @param {Date} _date the date to adjust\n * @param {number} numMonths the difference in months\n * @returns {Date} the adjusted date\n */\nconst addMonths = (_date, numMonths) => {\n  const newDate = new Date(_date.getTime());\n\n  const dateMonth = (newDate.getMonth() + 12 + numMonths) % 12;\n  newDate.setMonth(newDate.getMonth() + numMonths);\n  keepDateWithinMonth(newDate, dateMonth);\n\n  return newDate;\n};\n\n/**\n * Subtract months from date\n *\n * @param {Date} _date the date to adjust\n * @param {number} numMonths the difference in months\n * @returns {Date} the adjusted date\n */\nconst subMonths = (_date, numMonths) => addMonths(_date, -numMonths);\n\n/**\n * Add years to date and keep date within month\n *\n * @param {Date} _date the date to adjust\n * @param {number} numYears the difference in years\n * @returns {Date} the adjusted date\n */\nconst addYears = (_date, numYears) => addMonths(_date, numYears * 12);\n\n/**\n * Subtract years from date\n *\n * @param {Date} _date the date to adjust\n * @param {number} numYears the difference in years\n * @returns {Date} the adjusted date\n */\nconst subYears = (_date, numYears) => addYears(_date, -numYears);\n\n/**\n * Set months of date\n *\n * @param {Date} _date the date to adjust\n * @param {number} month zero-indexed month to set\n * @returns {Date} the adjusted date\n */\nconst setMonth = (_date, month) => {\n  const newDate = new Date(_date.getTime());\n\n  newDate.setMonth(month);\n  keepDateWithinMonth(newDate, month);\n\n  return newDate;\n};\n\n/**\n * Set year of date\n *\n * @param {Date} _date the date to adjust\n * @param {number} year the year to set\n * @returns {Date} the adjusted date\n */\nconst setYear = (_date, year) => {\n  const newDate = new Date(_date.getTime());\n\n  const month = newDate.getMonth();\n  newDate.setFullYear(year);\n  keepDateWithinMonth(newDate, month);\n\n  return newDate;\n};\n\n/**\n * Return the earliest date\n *\n * @param {Date} dateA date to compare\n * @param {Date} dateB date to compare\n * @returns {Date} the earliest date\n */\nconst min = (dateA, dateB) => {\n  let newDate = dateA;\n\n  if (dateB < dateA) {\n    newDate = dateB;\n  }\n\n  return new Date(newDate.getTime());\n};\n\n/**\n * Return the latest date\n *\n * @param {Date} dateA date to compare\n * @param {Date} dateB date to compare\n * @returns {Date} the latest date\n */\nconst max = (dateA, dateB) => {\n  let newDate = dateA;\n\n  if (dateB > dateA) {\n    newDate = dateB;\n  }\n\n  return new Date(newDate.getTime());\n};\n\n/**\n * Check if dates are the in the same year\n *\n * @param {Date} dateA date to compare\n * @param {Date} dateB date to compare\n * @returns {boolean} are dates in the same year\n */\nconst isSameYear = (dateA, dateB) =>\n  dateA && dateB && dateA.getFullYear() === dateB.getFullYear();\n\n/**\n * Check if dates are the in the same month\n *\n * @param {Date} dateA date to compare\n * @param {Date} dateB date to compare\n * @returns {boolean} are dates in the same month\n */\nconst isSameMonth = (dateA, dateB) =>\n  isSameYear(dateA, dateB) && dateA.getMonth() === dateB.getMonth();\n\n/**\n * Check if dates are the same date\n *\n * @param {Date} dateA the date to compare\n * @param {Date} dateA the date to compare\n * @returns {boolean} are dates the same date\n */\nconst isSameDay = (dateA, dateB) =>\n  isSameMonth(dateA, dateB) && dateA.getDate() === dateB.getDate();\n\n/**\n * return a new date within minimum and maximum date\n *\n * @param {Date} date date to check\n * @param {Date} minDate minimum date to allow\n * @param {Date} maxDate maximum date to allow\n * @returns {Date} the date between min and max\n */\nconst keepDateBetweenMinAndMax = (date, minDate, maxDate) => {\n  let newDate = date;\n\n  if (date < minDate) {\n    newDate = minDate;\n  } else if (maxDate && date > maxDate) {\n    newDate = maxDate;\n  }\n\n  return new Date(newDate.getTime());\n};\n\n/**\n * Check if dates is valid.\n *\n * @param {Date} date date to check\n * @param {Date} minDate minimum date to allow\n * @param {Date} maxDate maximum date to allow\n * @return {boolean} is there a day within the month within min and max dates\n */\nconst isDateWithinMinAndMax = (date, minDate, maxDate) =>\n  date >= minDate && (!maxDate || date <= maxDate);\n\n/**\n * Check if dates month is invalid.\n *\n * @param {Date} date date to check\n * @param {Date} minDate minimum date to allow\n * @param {Date} maxDate maximum date to allow\n * @return {boolean} is the month outside min or max dates\n */\nconst isDatesMonthOutsideMinOrMax = (date, minDate, maxDate) =>\n  lastDayOfMonth(date) < minDate || (maxDate && startOfMonth(date) > maxDate);\n\n/**\n * Check if dates year is invalid.\n *\n * @param {Date} date date to check\n * @param {Date} minDate minimum date to allow\n * @param {Date} maxDate maximum date to allow\n * @return {boolean} is the month outside min or max dates\n */\nconst isDatesYearOutsideMinOrMax = (date, minDate, maxDate) =>\n  lastDayOfMonth(setMonth(date, 11)) < minDate ||\n  (maxDate && startOfMonth(setMonth(date, 0)) > maxDate);\n\n/**\n * Parse a date with format M-D-YY\n *\n * @param {string} dateString the date string to parse\n * @param {string} dateFormat the format of the date string\n * @param {boolean} adjustDate should the date be adjusted\n * @returns {Date} the parsed date\n */\nconst parseDateString = (\n  dateString,\n  dateFormat = INTERNAL_DATE_FORMAT,\n  adjustDate = false\n) => {\n  let date;\n  let month;\n  let day;\n  let year;\n  let parsed;\n\n  if (dateString) {\n    let monthStr;\n    let dayStr;\n    let yearStr;\n\n    if (dateFormat === DEFAULT_EXTERNAL_DATE_FORMAT) {\n      [monthStr, dayStr, yearStr] = dateString.split(\"/\");\n    } else {\n      [yearStr, monthStr, dayStr] = dateString.split(\"-\");\n    }\n\n    if (yearStr) {\n      parsed = parseInt(yearStr, 10);\n      if (!Number.isNaN(parsed)) {\n        year = parsed;\n        if (adjustDate) {\n          year = Math.max(0, year);\n          if (yearStr.length < 3) {\n            const currentYear = today().getFullYear();\n            const currentYearStub =\n              currentYear - (currentYear % 10 ** yearStr.length);\n            year = currentYearStub + parsed;\n          }\n        }\n      }\n    }\n\n    if (monthStr) {\n      parsed = parseInt(monthStr, 10);\n      if (!Number.isNaN(parsed)) {\n        month = parsed;\n        if (adjustDate) {\n          month = Math.max(1, month);\n          month = Math.min(12, month);\n        }\n      }\n    }\n\n    if (month && dayStr && year != null) {\n      parsed = parseInt(dayStr, 10);\n      if (!Number.isNaN(parsed)) {\n        day = parsed;\n        if (adjustDate) {\n          const lastDayOfTheMonth = setDate(year, month, 0).getDate();\n          day = Math.max(1, day);\n          day = Math.min(lastDayOfTheMonth, day);\n        }\n      }\n    }\n\n    if (month && day && year != null) {\n      date = setDate(year, month - 1, day);\n    }\n  }\n\n  return date;\n};\n\n/**\n * Format a date to format MM-DD-YYYY\n *\n * @param {Date} date the date to format\n * @param {string} dateFormat the format of the date string\n * @returns {string} the formatted date string\n */\nconst formatDate = (date, dateFormat = INTERNAL_DATE_FORMAT) => {\n  const padZeros = (value, length) => `0000${value}`.slice(-length);\n\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  const year = date.getFullYear();\n\n  if (dateFormat === DEFAULT_EXTERNAL_DATE_FORMAT) {\n    return [padZeros(month, 2), padZeros(day, 2), padZeros(year, 4)].join(\"/\");\n  }\n\n  return [padZeros(year, 4), padZeros(month, 2), padZeros(day, 2)].join(\"-\");\n};\n\n// #endregion Date Manipulation Functions\n\n/**\n * Create a grid string from an array of html strings\n *\n * @param {string[]} htmlArray the array of html items\n * @param {number} rowSize the length of a row\n * @returns {string} the grid string\n */\nconst listToGridHtml = (htmlArray, rowSize) => {\n  const grid = [];\n  let row = [];\n\n  let i = 0;\n  while (i < htmlArray.length) {\n    row = [];\n\n    const tr = document.createElement(\"tr\");\n    while (i < htmlArray.length && row.length < rowSize) {\n      const td = document.createElement(\"td\");\n      td.insertAdjacentElement(\"beforeend\", htmlArray[i]);\n      row.push(td);\n      i += 1;\n    }\n\n    row.forEach((element) => {\n      tr.insertAdjacentElement(\"beforeend\", element);\n    });\n\n    grid.push(tr);\n  }\n\n  return grid;\n};\n\nconst createTableBody = (grid) => {\n  const tableBody = document.createElement(\"tbody\");\n  grid.forEach((element) => {\n    tableBody.insertAdjacentElement(\"beforeend\", element);\n  });\n\n  return tableBody;\n};\n\n/**\n * set the value of the element and dispatch a change event\n *\n * @param {HTMLInputElement} el The element to update\n * @param {string} value The new value of the element\n */\nconst changeElementValue = (el, value = \"\") => {\n  const elementToChange = el;\n  elementToChange.value = value;\n\n  const event = new CustomEvent(\"change\", {\n    bubbles: true,\n    cancelable: true,\n    detail: { value },\n  });\n  elementToChange.dispatchEvent(event);\n};\n\n/**\n * The properties and elements within the date picker.\n * @typedef {Object} DatePickerContext\n * @property {HTMLDivElement} calendarEl\n * @property {HTMLElement} datePickerEl\n * @property {HTMLInputElement} internalInputEl\n * @property {HTMLInputElement} externalInputEl\n * @property {HTMLDivElement} statusEl\n * @property {HTMLDivElement} firstYearChunkEl\n * @property {Date} calendarDate\n * @property {Date} minDate\n * @property {Date} maxDate\n * @property {Date} selectedDate\n * @property {Date} rangeDate\n * @property {Date} defaultDate\n */\n\n/**\n * Get an object of the properties and elements belonging directly to the given\n * date picker component.\n *\n * @param {HTMLElement} el the element within the date picker\n * @returns {DatePickerContext} elements\n */\nconst getDatePickerContext = (el) => {\n  const datePickerEl = el.closest(DATE_PICKER);\n\n  if (!datePickerEl) {\n    throw new Error(`Element is missing outer ${DATE_PICKER}`);\n  }\n\n  const internalInputEl = datePickerEl.querySelector(\n    DATE_PICKER_INTERNAL_INPUT\n  );\n  const externalInputEl = datePickerEl.querySelector(\n    DATE_PICKER_EXTERNAL_INPUT\n  );\n  const calendarEl = datePickerEl.querySelector(DATE_PICKER_CALENDAR);\n  const toggleBtnEl = datePickerEl.querySelector(DATE_PICKER_BUTTON);\n  const statusEl = datePickerEl.querySelector(DATE_PICKER_STATUS);\n  const firstYearChunkEl = datePickerEl.querySelector(CALENDAR_YEAR);\n\n  const inputDate = parseDateString(\n    externalInputEl.value,\n    DEFAULT_EXTERNAL_DATE_FORMAT,\n    true\n  );\n  const selectedDate = parseDateString(internalInputEl.value);\n\n  const calendarDate = parseDateString(calendarEl.dataset.value);\n  const minDate = parseDateString(datePickerEl.dataset.minDate);\n  const maxDate = parseDateString(datePickerEl.dataset.maxDate);\n  const rangeDate = parseDateString(datePickerEl.dataset.rangeDate);\n  const defaultDate = parseDateString(datePickerEl.dataset.defaultDate);\n\n  if (minDate && maxDate && minDate > maxDate) {\n    throw new Error(\"Minimum date cannot be after maximum date\");\n  }\n\n  return {\n    calendarDate,\n    minDate,\n    toggleBtnEl,\n    selectedDate,\n    maxDate,\n    firstYearChunkEl,\n    datePickerEl,\n    inputDate,\n    internalInputEl,\n    externalInputEl,\n    calendarEl,\n    rangeDate,\n    defaultDate,\n    statusEl,\n  };\n};\n\n/**\n * Disable the date picker component\n *\n * @param {HTMLElement} el An element within the date picker component\n */\nconst disable = (el) => {\n  const { externalInputEl, toggleBtnEl } = getDatePickerContext(el);\n\n  toggleBtnEl.disabled = true;\n  externalInputEl.disabled = true;\n};\n\n/**\n * Check for aria-disabled on initialization\n *\n * @param {HTMLElement} el An element within the date picker component\n */\nconst ariaDisable = (el) => {\n  const { externalInputEl, toggleBtnEl } = getDatePickerContext(el);\n\n  toggleBtnEl.setAttribute(\"aria-disabled\", true);\n  externalInputEl.setAttribute(\"aria-disabled\", true);\n};\n\n/**\n * Enable the date picker component\n *\n * @param {HTMLElement} el An element within the date picker component\n */\nconst enable = (el) => {\n  const { externalInputEl, toggleBtnEl } = getDatePickerContext(el);\n\n  toggleBtnEl.disabled = false;\n  externalInputEl.disabled = false;\n};\n\n// #region Validation\n\n/**\n * Validate the value in the input as a valid date of format M/D/YYYY\n *\n * @param {HTMLElement} el An element within the date picker component\n */\nconst isDateInputInvalid = (el) => {\n  const { externalInputEl, minDate, maxDate } = getDatePickerContext(el);\n\n  const dateString = externalInputEl.value;\n  let isInvalid = false;\n\n  if (dateString) {\n    isInvalid = true;\n\n    const dateStringParts = dateString.split(\"/\");\n    const [month, day, year] = dateStringParts.map((str) => {\n      let value;\n      const parsed = parseInt(str, 10);\n      if (!Number.isNaN(parsed)) value = parsed;\n      return value;\n    });\n\n    if (month && day && year != null) {\n      const checkDate = setDate(year, month - 1, day);\n\n      if (\n        checkDate.getMonth() === month - 1 &&\n        checkDate.getDate() === day &&\n        checkDate.getFullYear() === year &&\n        dateStringParts[2].length === 4 &&\n        isDateWithinMinAndMax(checkDate, minDate, maxDate)\n      ) {\n        isInvalid = false;\n      }\n    }\n  }\n\n  return isInvalid;\n};\n\n/**\n * Validate the value in the input as a valid date of format M/D/YYYY\n *\n * @param {HTMLElement} el An element within the date picker component\n */\nconst validateDateInput = (el) => {\n  const { externalInputEl } = getDatePickerContext(el);\n  const isInvalid = isDateInputInvalid(externalInputEl);\n\n  if (isInvalid && !externalInputEl.validationMessage) {\n    externalInputEl.setCustomValidity(VALIDATION_MESSAGE);\n  }\n\n  if (!isInvalid && externalInputEl.validationMessage === VALIDATION_MESSAGE) {\n    externalInputEl.setCustomValidity(\"\");\n  }\n};\n\n// #endregion Validation\n\n/**\n * Enable the date picker component\n *\n * @param {HTMLElement} el An element within the date picker component\n */\nconst reconcileInputValues = (el) => {\n  const { internalInputEl, inputDate } = getDatePickerContext(el);\n  let newValue = \"\";\n\n  if (inputDate && !isDateInputInvalid(el)) {\n    newValue = formatDate(inputDate);\n  }\n\n  if (internalInputEl.value !== newValue) {\n    changeElementValue(internalInputEl, newValue);\n  }\n};\n\n/**\n * Select the value of the date picker inputs.\n *\n * @param {HTMLButtonElement} el An element within the date picker component\n * @param {string} dateString The date string to update in YYYY-MM-DD format\n */\nconst setCalendarValue = (el, dateString) => {\n  const parsedDate = parseDateString(dateString);\n\n  if (parsedDate) {\n    const formattedDate = formatDate(parsedDate, DEFAULT_EXTERNAL_DATE_FORMAT);\n\n    const { datePickerEl, internalInputEl, externalInputEl } =\n      getDatePickerContext(el);\n\n    changeElementValue(internalInputEl, dateString);\n    changeElementValue(externalInputEl, formattedDate);\n\n    validateDateInput(datePickerEl);\n  }\n};\n\n/**\n * Enhance an input with the date picker elements\n *\n * @param {HTMLElement} el The initial wrapping element of the date picker component\n */\nconst enhanceDatePicker = (el) => {\n  const datePickerEl = el.closest(DATE_PICKER);\n  const { defaultValue } = datePickerEl.dataset;\n\n  const internalInputEl = datePickerEl.querySelector(`input`);\n\n  if (!internalInputEl) {\n    throw new Error(`${DATE_PICKER} is missing inner input`);\n  }\n\n  if (internalInputEl.value) {\n    internalInputEl.value = \"\";\n  }\n\n  const minDate = parseDateString(\n    datePickerEl.dataset.minDate || internalInputEl.getAttribute(\"min\")\n  );\n  datePickerEl.dataset.minDate = minDate\n    ? formatDate(minDate)\n    : DEFAULT_MIN_DATE;\n\n  const maxDate = parseDateString(\n    datePickerEl.dataset.maxDate || internalInputEl.getAttribute(\"max\")\n  );\n  if (maxDate) {\n    datePickerEl.dataset.maxDate = formatDate(maxDate);\n  }\n\n  const calendarWrapper = document.createElement(\"div\");\n  calendarWrapper.classList.add(DATE_PICKER_WRAPPER_CLASS);\n\n  const externalInputEl = internalInputEl.cloneNode();\n  externalInputEl.classList.add(DATE_PICKER_EXTERNAL_INPUT_CLASS);\n  externalInputEl.type = \"text\";\n\n  calendarWrapper.appendChild(externalInputEl);\n  calendarWrapper.insertAdjacentHTML(\n    \"beforeend\",\n    Sanitizer.escapeHTML`\n    <button type=\"button\" class=\"${DATE_PICKER_BUTTON_CLASS}\" aria-haspopup=\"true\" aria-label=\"Toggle calendar\"></button>\n    <div class=\"${DATE_PICKER_CALENDAR_CLASS}\" role=\"application\" hidden></div>\n    <div class=\"usa-sr-only ${DATE_PICKER_STATUS_CLASS}\" role=\"status\" aria-live=\"polite\"></div>`\n  );\n\n  internalInputEl.setAttribute(\"aria-hidden\", \"true\");\n  internalInputEl.setAttribute(\"tabindex\", \"-1\");\n  internalInputEl.style.display = \"none\";\n  internalInputEl.classList.add(DATE_PICKER_INTERNAL_INPUT_CLASS);\n  internalInputEl.removeAttribute(\"id\");\n  internalInputEl.removeAttribute(\"name\");\n  internalInputEl.required = false;\n\n  datePickerEl.appendChild(calendarWrapper);\n  datePickerEl.classList.add(DATE_PICKER_INITIALIZED_CLASS);\n\n  if (defaultValue) {\n    setCalendarValue(datePickerEl, defaultValue);\n  }\n\n  if (internalInputEl.disabled) {\n    disable(datePickerEl);\n    internalInputEl.disabled = false;\n  }\n\n  if (internalInputEl.hasAttribute(\"aria-disabled\")) {\n    ariaDisable(datePickerEl);\n    internalInputEl.removeAttribute(\"aria-disabled\");\n  }\n};\n\n// #region Calendar - Date Selection View\n\n/**\n * render the calendar.\n *\n * @param {HTMLElement} el An element within the date picker component\n * @param {Date} _dateToDisplay a date to render on the calendar\n * @returns {HTMLElement} a reference to the new calendar element\n */\nconst renderCalendar = (el, _dateToDisplay) => {\n  const {\n    datePickerEl,\n    calendarEl,\n    statusEl,\n    selectedDate,\n    maxDate,\n    minDate,\n    rangeDate,\n  } = getDatePickerContext(el);\n  const todaysDate = today();\n  let dateToDisplay = _dateToDisplay || todaysDate;\n\n  const calendarWasHidden = calendarEl.hidden;\n\n  const focusedDate = addDays(dateToDisplay, 0);\n  const focusedMonth = dateToDisplay.getMonth();\n  const focusedYear = dateToDisplay.getFullYear();\n\n  const prevMonth = subMonths(dateToDisplay, 1);\n  const nextMonth = addMonths(dateToDisplay, 1);\n\n  const currentFormattedDate = formatDate(dateToDisplay);\n\n  const firstOfMonth = startOfMonth(dateToDisplay);\n  const prevButtonsDisabled = isSameMonth(dateToDisplay, minDate);\n  const nextButtonsDisabled = isSameMonth(dateToDisplay, maxDate);\n\n  const rangeConclusionDate = selectedDate || dateToDisplay;\n  const rangeStartDate = rangeDate && min(rangeConclusionDate, rangeDate);\n  const rangeEndDate = rangeDate && max(rangeConclusionDate, rangeDate);\n\n  const withinRangeStartDate = rangeDate && addDays(rangeStartDate, 1);\n  const withinRangeEndDate = rangeDate && subDays(rangeEndDate, 1);\n\n  const monthLabel = MONTH_LABELS[focusedMonth];\n\n  const generateDateHtml = (dateToRender) => {\n    const classes = [CALENDAR_DATE_CLASS];\n    const day = dateToRender.getDate();\n    const month = dateToRender.getMonth();\n    const year = dateToRender.getFullYear();\n    const dayOfWeek = dateToRender.getDay();\n\n    const formattedDate = formatDate(dateToRender);\n\n    let tabindex = \"-1\";\n\n    const isDisabled = !isDateWithinMinAndMax(dateToRender, minDate, maxDate);\n    const isSelected = isSameDay(dateToRender, selectedDate);\n\n    if (isSameMonth(dateToRender, prevMonth)) {\n      classes.push(CALENDAR_DATE_PREVIOUS_MONTH_CLASS);\n    }\n\n    if (isSameMonth(dateToRender, focusedDate)) {\n      classes.push(CALENDAR_DATE_CURRENT_MONTH_CLASS);\n    }\n\n    if (isSameMonth(dateToRender, nextMonth)) {\n      classes.push(CALENDAR_DATE_NEXT_MONTH_CLASS);\n    }\n\n    if (isSelected) {\n      classes.push(CALENDAR_DATE_SELECTED_CLASS);\n    }\n\n    if (isSameDay(dateToRender, todaysDate)) {\n      classes.push(CALENDAR_DATE_TODAY_CLASS);\n    }\n\n    if (rangeDate) {\n      if (isSameDay(dateToRender, rangeDate)) {\n        classes.push(CALENDAR_DATE_RANGE_DATE_CLASS);\n      }\n\n      if (isSameDay(dateToRender, rangeStartDate)) {\n        classes.push(CALENDAR_DATE_RANGE_DATE_START_CLASS);\n      }\n\n      if (isSameDay(dateToRender, rangeEndDate)) {\n        classes.push(CALENDAR_DATE_RANGE_DATE_END_CLASS);\n      }\n\n      if (\n        isDateWithinMinAndMax(\n          dateToRender,\n          withinRangeStartDate,\n          withinRangeEndDate\n        )\n      ) {\n        classes.push(CALENDAR_DATE_WITHIN_RANGE_CLASS);\n      }\n    }\n\n    if (isSameDay(dateToRender, focusedDate)) {\n      tabindex = \"0\";\n      classes.push(CALENDAR_DATE_FOCUSED_CLASS);\n    }\n\n    const monthStr = MONTH_LABELS[month];\n    const dayStr = DAY_OF_WEEK_LABELS[dayOfWeek];\n\n    const btn = document.createElement(\"button\");\n    btn.setAttribute(\"type\", \"button\");\n    btn.setAttribute(\"tabindex\", tabindex);\n    btn.setAttribute(\"class\", classes.join(\" \"));\n    btn.setAttribute(\"data-day\", day);\n    btn.setAttribute(\"data-month\", month + 1);\n    btn.setAttribute(\"data-year\", year);\n    btn.setAttribute(\"data-value\", formattedDate);\n    btn.setAttribute(\n      \"aria-label\",\n      Sanitizer.escapeHTML`${day} ${monthStr} ${year} ${dayStr}`\n    );\n    btn.setAttribute(\"aria-selected\", isSelected ? \"true\" : \"false\");\n    if (isDisabled === true) {\n      btn.disabled = true;\n    }\n    btn.textContent = day;\n\n    return btn;\n  };\n\n  // set date to first rendered day\n  dateToDisplay = startOfWeek(firstOfMonth);\n\n  const days = [];\n\n  while (\n    days.length < 28 ||\n    dateToDisplay.getMonth() === focusedMonth ||\n    days.length % 7 !== 0\n  ) {\n    days.push(generateDateHtml(dateToDisplay));\n    dateToDisplay = addDays(dateToDisplay, 1);\n  }\n\n  const datesGrid = listToGridHtml(days, 7);\n\n  const newCalendar = calendarEl.cloneNode();\n  newCalendar.dataset.value = currentFormattedDate;\n  newCalendar.style.top = `${datePickerEl.offsetHeight}px`;\n  newCalendar.hidden = false;\n  newCalendar.innerHTML = Sanitizer.escapeHTML`\n    <div tabindex=\"-1\" class=\"${CALENDAR_DATE_PICKER_CLASS}\">\n      <div class=\"${CALENDAR_ROW_CLASS}\">\n        <div class=\"${CALENDAR_CELL_CLASS} ${CALENDAR_CELL_CENTER_ITEMS_CLASS}\">\n          <button\n            type=\"button\"\n            class=\"${CALENDAR_PREVIOUS_YEAR_CLASS}\"\n            aria-label=\"Navigate back one year\"\n            ${prevButtonsDisabled ? `disabled=\"disabled\"` : \"\"}\n          ></button>\n        </div>\n        <div class=\"${CALENDAR_CELL_CLASS} ${CALENDAR_CELL_CENTER_ITEMS_CLASS}\">\n          <button\n            type=\"button\"\n            class=\"${CALENDAR_PREVIOUS_MONTH_CLASS}\"\n            aria-label=\"Navigate back one month\"\n            ${prevButtonsDisabled ? `disabled=\"disabled\"` : \"\"}\n          ></button>\n        </div>\n        <div class=\"${CALENDAR_CELL_CLASS} ${CALENDAR_MONTH_LABEL_CLASS}\">\n          <button\n            type=\"button\"\n            class=\"${CALENDAR_MONTH_SELECTION_CLASS}\" aria-label=\"${monthLabel}. Select month\"\n          >${monthLabel}</button>\n          <button\n            type=\"button\"\n            class=\"${CALENDAR_YEAR_SELECTION_CLASS}\" aria-label=\"${focusedYear}. Select year\"\n          >${focusedYear}</button>\n        </div>\n        <div class=\"${CALENDAR_CELL_CLASS} ${CALENDAR_CELL_CENTER_ITEMS_CLASS}\">\n          <button\n            type=\"button\"\n            class=\"${CALENDAR_NEXT_MONTH_CLASS}\"\n            aria-label=\"Navigate forward one month\"\n            ${nextButtonsDisabled ? `disabled=\"disabled\"` : \"\"}\n          ></button>\n        </div>\n        <div class=\"${CALENDAR_CELL_CLASS} ${CALENDAR_CELL_CENTER_ITEMS_CLASS}\">\n          <button\n            type=\"button\"\n            class=\"${CALENDAR_NEXT_YEAR_CLASS}\"\n            aria-label=\"Navigate forward one year\"\n            ${nextButtonsDisabled ? `disabled=\"disabled\"` : \"\"}\n          ></button>\n        </div>\n      </div>\n    </div>\n    `;\n\n  const table = document.createElement(\"table\");\n  table.setAttribute(\"class\", CALENDAR_TABLE_CLASS);\n\n  const tableHead = document.createElement(\"thead\");\n  table.insertAdjacentElement(\"beforeend\", tableHead);\n  const tableHeadRow = document.createElement(\"tr\");\n  tableHead.insertAdjacentElement(\"beforeend\", tableHeadRow);\n\n  const daysOfWeek = {\n    Sunday: \"S\",\n    Monday: \"M\",\n    Tuesday: \"T\",\n    Wednesday: \"W\",\n    Thursday: \"Th\",\n    Friday: \"Fr\",\n    Saturday: \"S\",\n  };\n\n  Object.keys(daysOfWeek).forEach((key) => {\n    const th = document.createElement(\"th\");\n    th.setAttribute(\"class\", CALENDAR_DAY_OF_WEEK_CLASS);\n    th.setAttribute(\"scope\", \"col\");\n    th.setAttribute(\"aria-label\", key);\n    th.textContent = daysOfWeek[key];\n    tableHeadRow.insertAdjacentElement(\"beforeend\", th);\n  });\n\n  const tableBody = createTableBody(datesGrid);\n  table.insertAdjacentElement(\"beforeend\", tableBody);\n\n  // Container for Years, Months, and Days\n  const datePickerCalendarContainer =\n    newCalendar.querySelector(CALENDAR_DATE_PICKER);\n\n  datePickerCalendarContainer.insertAdjacentElement(\"beforeend\", table);\n\n  calendarEl.parentNode.replaceChild(newCalendar, calendarEl);\n\n  datePickerEl.classList.add(DATE_PICKER_ACTIVE_CLASS);\n\n  const statuses = [];\n\n  if (isSameDay(selectedDate, focusedDate)) {\n    statuses.push(\"Selected date\");\n  }\n\n  if (calendarWasHidden) {\n    statuses.push(\n      \"You can navigate by day using left and right arrows\",\n      \"Weeks by using up and down arrows\",\n      \"Months by using page up and page down keys\",\n      \"Years by using shift plus page up and shift plus page down\",\n      \"Home and end keys navigate to the beginning and end of a week\"\n    );\n    statusEl.textContent = \"\";\n  } else {\n    statuses.push(`${monthLabel} ${focusedYear}`);\n  }\n  statusEl.textContent = statuses.join(\". \");\n\n  return newCalendar;\n};\n\n/**\n * Navigate back one year and display the calendar.\n *\n * @param {HTMLButtonElement} _buttonEl An element within the date picker component\n */\nconst displayPreviousYear = (_buttonEl) => {\n  if (_buttonEl.disabled) return;\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(_buttonEl);\n  let date = subYears(calendarDate, 1);\n  date = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  const newCalendar = renderCalendar(calendarEl, date);\n\n  let nextToFocus = newCalendar.querySelector(CALENDAR_PREVIOUS_YEAR);\n  if (nextToFocus.disabled) {\n    nextToFocus = newCalendar.querySelector(CALENDAR_DATE_PICKER);\n  }\n  nextToFocus.focus();\n};\n\n/**\n * Navigate back one month and display the calendar.\n *\n * @param {HTMLButtonElement} _buttonEl An element within the date picker component\n */\nconst displayPreviousMonth = (_buttonEl) => {\n  if (_buttonEl.disabled) return;\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(_buttonEl);\n  let date = subMonths(calendarDate, 1);\n  date = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  const newCalendar = renderCalendar(calendarEl, date);\n\n  let nextToFocus = newCalendar.querySelector(CALENDAR_PREVIOUS_MONTH);\n  if (nextToFocus.disabled) {\n    nextToFocus = newCalendar.querySelector(CALENDAR_DATE_PICKER);\n  }\n  nextToFocus.focus();\n};\n\n/**\n * Navigate forward one month and display the calendar.\n *\n * @param {HTMLButtonElement} _buttonEl An element within the date picker component\n */\nconst displayNextMonth = (_buttonEl) => {\n  if (_buttonEl.disabled) return;\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(_buttonEl);\n  let date = addMonths(calendarDate, 1);\n  date = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  const newCalendar = renderCalendar(calendarEl, date);\n\n  let nextToFocus = newCalendar.querySelector(CALENDAR_NEXT_MONTH);\n  if (nextToFocus.disabled) {\n    nextToFocus = newCalendar.querySelector(CALENDAR_DATE_PICKER);\n  }\n  nextToFocus.focus();\n};\n\n/**\n * Navigate forward one year and display the calendar.\n *\n * @param {HTMLButtonElement} _buttonEl An element within the date picker component\n */\nconst displayNextYear = (_buttonEl) => {\n  if (_buttonEl.disabled) return;\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(_buttonEl);\n  let date = addYears(calendarDate, 1);\n  date = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  const newCalendar = renderCalendar(calendarEl, date);\n\n  let nextToFocus = newCalendar.querySelector(CALENDAR_NEXT_YEAR);\n  if (nextToFocus.disabled) {\n    nextToFocus = newCalendar.querySelector(CALENDAR_DATE_PICKER);\n  }\n  nextToFocus.focus();\n};\n\n/**\n * Hide the calendar of a date picker component.\n *\n * @param {HTMLElement} el An element within the date picker component\n */\nconst hideCalendar = (el) => {\n  const { datePickerEl, calendarEl, statusEl } = getDatePickerContext(el);\n\n  datePickerEl.classList.remove(DATE_PICKER_ACTIVE_CLASS);\n  calendarEl.hidden = true;\n  statusEl.textContent = \"\";\n};\n\n/**\n * Select a date within the date picker component.\n *\n * @param {HTMLButtonElement} calendarDateEl A date element within the date picker component\n */\nconst selectDate = (calendarDateEl) => {\n  if (calendarDateEl.disabled) return;\n\n  const { datePickerEl, externalInputEl } =\n    getDatePickerContext(calendarDateEl);\n\n  setCalendarValue(calendarDateEl, calendarDateEl.dataset.value);\n  hideCalendar(datePickerEl);\n\n  externalInputEl.focus();\n};\n\n/**\n * Toggle the calendar.\n *\n * @param {HTMLButtonElement} el An element within the date picker component\n */\nconst toggleCalendar = (el) => {\n  if (el.disabled) return;\n  const { calendarEl, inputDate, minDate, maxDate, defaultDate } =\n    getDatePickerContext(el);\n\n  if (calendarEl.hidden) {\n    const dateToDisplay = keepDateBetweenMinAndMax(\n      inputDate || defaultDate || today(),\n      minDate,\n      maxDate\n    );\n    const newCalendar = renderCalendar(calendarEl, dateToDisplay);\n    newCalendar.querySelector(CALENDAR_DATE_FOCUSED).focus();\n  } else {\n    hideCalendar(el);\n  }\n};\n\n/**\n * Update the calendar when visible.\n *\n * @param {HTMLElement} el an element within the date picker\n */\nconst updateCalendarIfVisible = (el) => {\n  const { calendarEl, inputDate, minDate, maxDate } = getDatePickerContext(el);\n  const calendarShown = !calendarEl.hidden;\n\n  if (calendarShown && inputDate) {\n    const dateToDisplay = keepDateBetweenMinAndMax(inputDate, minDate, maxDate);\n    renderCalendar(calendarEl, dateToDisplay);\n  }\n};\n\n// #endregion Calendar - Date Selection View\n\n// #region Calendar - Month Selection View\n/**\n * Display the month selection screen in the date picker.\n *\n * @param {HTMLButtonElement} el An element within the date picker component\n * @returns {HTMLElement} a reference to the new calendar element\n */\nconst displayMonthSelection = (el, monthToDisplay) => {\n  const { calendarEl, statusEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(el);\n\n  const selectedMonth = calendarDate.getMonth();\n  const focusedMonth = monthToDisplay == null ? selectedMonth : monthToDisplay;\n\n  const months = MONTH_LABELS.map((month, index) => {\n    const monthToCheck = setMonth(calendarDate, index);\n\n    const isDisabled = isDatesMonthOutsideMinOrMax(\n      monthToCheck,\n      minDate,\n      maxDate\n    );\n\n    let tabindex = \"-1\";\n\n    const classes = [CALENDAR_MONTH_CLASS];\n    const isSelected = index === selectedMonth;\n\n    if (index === focusedMonth) {\n      tabindex = \"0\";\n      classes.push(CALENDAR_MONTH_FOCUSED_CLASS);\n    }\n\n    if (isSelected) {\n      classes.push(CALENDAR_MONTH_SELECTED_CLASS);\n    }\n\n    const btn = document.createElement(\"button\");\n    btn.setAttribute(\"type\", \"button\");\n    btn.setAttribute(\"tabindex\", tabindex);\n    btn.setAttribute(\"class\", classes.join(\" \"));\n    btn.setAttribute(\"data-value\", index);\n    btn.setAttribute(\"data-label\", month);\n    btn.setAttribute(\"aria-selected\", isSelected ? \"true\" : \"false\");\n    if (isDisabled === true) {\n      btn.disabled = true;\n    }\n    btn.textContent = month;\n\n    return btn;\n  });\n\n  const monthsHtml = document.createElement(\"div\");\n  monthsHtml.setAttribute(\"tabindex\", \"-1\");\n  monthsHtml.setAttribute(\"class\", CALENDAR_MONTH_PICKER_CLASS);\n\n  const table = document.createElement(\"table\");\n  table.setAttribute(\"class\", CALENDAR_TABLE_CLASS);\n  table.setAttribute(\"role\", \"presentation\");\n\n  const monthsGrid = listToGridHtml(months, 3);\n  const tableBody = createTableBody(monthsGrid);\n  table.insertAdjacentElement(\"beforeend\", tableBody);\n  monthsHtml.insertAdjacentElement(\"beforeend\", table);\n\n  const newCalendar = calendarEl.cloneNode();\n  newCalendar.insertAdjacentElement(\"beforeend\", monthsHtml);\n  calendarEl.parentNode.replaceChild(newCalendar, calendarEl);\n\n  statusEl.textContent = \"Select a month.\";\n\n  return newCalendar;\n};\n\n/**\n * Select a month in the date picker component.\n *\n * @param {HTMLButtonElement} monthEl An month element within the date picker component\n */\nconst selectMonth = (monthEl) => {\n  if (monthEl.disabled) return;\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(monthEl);\n  const selectedMonth = parseInt(monthEl.dataset.value, 10);\n  let date = setMonth(calendarDate, selectedMonth);\n  date = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  const newCalendar = renderCalendar(calendarEl, date);\n  newCalendar.querySelector(CALENDAR_DATE_FOCUSED).focus();\n};\n\n// #endregion Calendar - Month Selection View\n\n// #region Calendar - Year Selection View\n\n/**\n * Display the year selection screen in the date picker.\n *\n * @param {HTMLButtonElement} el An element within the date picker component\n * @param {number} yearToDisplay year to display in year selection\n * @returns {HTMLElement} a reference to the new calendar element\n */\nconst displayYearSelection = (el, yearToDisplay) => {\n  const { calendarEl, statusEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(el);\n\n  const selectedYear = calendarDate.getFullYear();\n  const focusedYear = yearToDisplay == null ? selectedYear : yearToDisplay;\n\n  let yearToChunk = focusedYear;\n  yearToChunk -= yearToChunk % YEAR_CHUNK;\n  yearToChunk = Math.max(0, yearToChunk);\n\n  const prevYearChunkDisabled = isDatesYearOutsideMinOrMax(\n    setYear(calendarDate, yearToChunk - 1),\n    minDate,\n    maxDate\n  );\n\n  const nextYearChunkDisabled = isDatesYearOutsideMinOrMax(\n    setYear(calendarDate, yearToChunk + YEAR_CHUNK),\n    minDate,\n    maxDate\n  );\n\n  const years = [];\n  let yearIndex = yearToChunk;\n  while (years.length < YEAR_CHUNK) {\n    const isDisabled = isDatesYearOutsideMinOrMax(\n      setYear(calendarDate, yearIndex),\n      minDate,\n      maxDate\n    );\n\n    let tabindex = \"-1\";\n\n    const classes = [CALENDAR_YEAR_CLASS];\n    const isSelected = yearIndex === selectedYear;\n\n    if (yearIndex === focusedYear) {\n      tabindex = \"0\";\n      classes.push(CALENDAR_YEAR_FOCUSED_CLASS);\n    }\n\n    if (isSelected) {\n      classes.push(CALENDAR_YEAR_SELECTED_CLASS);\n    }\n\n    const btn = document.createElement(\"button\");\n    btn.setAttribute(\"type\", \"button\");\n    btn.setAttribute(\"tabindex\", tabindex);\n    btn.setAttribute(\"class\", classes.join(\" \"));\n    btn.setAttribute(\"data-value\", yearIndex);\n    btn.setAttribute(\"aria-selected\", isSelected ? \"true\" : \"false\");\n    if (isDisabled === true) {\n      btn.disabled = true;\n    }\n    btn.textContent = yearIndex;\n\n    years.push(btn);\n    yearIndex += 1;\n  }\n\n  const newCalendar = calendarEl.cloneNode();\n\n  // create the years calendar wrapper\n  const yearsCalendarWrapper = document.createElement(\"div\");\n  yearsCalendarWrapper.setAttribute(\"tabindex\", \"-1\");\n  yearsCalendarWrapper.setAttribute(\"class\", CALENDAR_YEAR_PICKER_CLASS);\n\n  // create table parent\n  const yearsTableParent = document.createElement(\"table\");\n  yearsTableParent.setAttribute(\"class\", CALENDAR_TABLE_CLASS);\n\n  // create table body and table row\n  const yearsHTMLTableBody = document.createElement(\"tbody\");\n  const yearsHTMLTableBodyRow = document.createElement(\"tr\");\n\n  // create previous button\n  const previousYearsBtn = document.createElement(\"button\");\n  previousYearsBtn.setAttribute(\"type\", \"button\");\n  previousYearsBtn.setAttribute(\"class\", CALENDAR_PREVIOUS_YEAR_CHUNK_CLASS);\n  previousYearsBtn.setAttribute(\n    \"aria-label\",\n    `Navigate back ${YEAR_CHUNK} years`\n  );\n  if (prevYearChunkDisabled === true) {\n    previousYearsBtn.disabled = true;\n  }\n  previousYearsBtn.innerHTML = Sanitizer.escapeHTML`&nbsp`;\n\n  // create next button\n  const nextYearsBtn = document.createElement(\"button\");\n  nextYearsBtn.setAttribute(\"type\", \"button\");\n  nextYearsBtn.setAttribute(\"class\", CALENDAR_NEXT_YEAR_CHUNK_CLASS);\n  nextYearsBtn.setAttribute(\n    \"aria-label\",\n    `Navigate forward ${YEAR_CHUNK} years`\n  );\n  if (nextYearChunkDisabled === true) {\n    nextYearsBtn.disabled = true;\n  }\n  nextYearsBtn.innerHTML = Sanitizer.escapeHTML`&nbsp`;\n\n  // create the actual years table\n  const yearsTable = document.createElement(\"table\");\n  yearsTable.setAttribute(\"class\", CALENDAR_TABLE_CLASS);\n  yearsTable.setAttribute(\"role\", \"presentation\");\n\n  // create the years child table\n  const yearsGrid = listToGridHtml(years, 3);\n  const yearsTableBody = createTableBody(yearsGrid);\n\n  // append the grid to the years child table\n  yearsTable.insertAdjacentElement(\"beforeend\", yearsTableBody);\n\n  // create the prev button td and append the prev button\n  const yearsHTMLTableBodyDetailPrev = document.createElement(\"td\");\n  yearsHTMLTableBodyDetailPrev.insertAdjacentElement(\n    \"beforeend\",\n    previousYearsBtn\n  );\n\n  // create the years td and append the years child table\n  const yearsHTMLTableBodyYearsDetail = document.createElement(\"td\");\n  yearsHTMLTableBodyYearsDetail.setAttribute(\"colspan\", \"3\");\n  yearsHTMLTableBodyYearsDetail.insertAdjacentElement(\"beforeend\", yearsTable);\n\n  // create the next button td and append the next button\n  const yearsHTMLTableBodyDetailNext = document.createElement(\"td\");\n  yearsHTMLTableBodyDetailNext.insertAdjacentElement(\"beforeend\", nextYearsBtn);\n\n  // append the three td to the years child table row\n  yearsHTMLTableBodyRow.insertAdjacentElement(\n    \"beforeend\",\n    yearsHTMLTableBodyDetailPrev\n  );\n  yearsHTMLTableBodyRow.insertAdjacentElement(\n    \"beforeend\",\n    yearsHTMLTableBodyYearsDetail\n  );\n  yearsHTMLTableBodyRow.insertAdjacentElement(\n    \"beforeend\",\n    yearsHTMLTableBodyDetailNext\n  );\n\n  // append the table row to the years child table body\n  yearsHTMLTableBody.insertAdjacentElement(\"beforeend\", yearsHTMLTableBodyRow);\n\n  // append the years table body to the years parent table\n  yearsTableParent.insertAdjacentElement(\"beforeend\", yearsHTMLTableBody);\n\n  // append the parent table to the calendar wrapper\n  yearsCalendarWrapper.insertAdjacentElement(\"beforeend\", yearsTableParent);\n\n  // append the years calender to the new calendar\n  newCalendar.insertAdjacentElement(\"beforeend\", yearsCalendarWrapper);\n\n  // replace calendar\n  calendarEl.parentNode.replaceChild(newCalendar, calendarEl);\n\n  statusEl.textContent = Sanitizer.escapeHTML`Showing years ${yearToChunk} to ${\n    yearToChunk + YEAR_CHUNK - 1\n  }. Select a year.`;\n\n  return newCalendar;\n};\n\n/**\n * Navigate back by years and display the year selection screen.\n *\n * @param {HTMLButtonElement} el An element within the date picker component\n */\nconst displayPreviousYearChunk = (el) => {\n  if (el.disabled) return;\n\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(el);\n  const yearEl = calendarEl.querySelector(CALENDAR_YEAR_FOCUSED);\n  const selectedYear = parseInt(yearEl.textContent, 10);\n\n  let adjustedYear = selectedYear - YEAR_CHUNK;\n  adjustedYear = Math.max(0, adjustedYear);\n\n  const date = setYear(calendarDate, adjustedYear);\n  const cappedDate = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  const newCalendar = displayYearSelection(\n    calendarEl,\n    cappedDate.getFullYear()\n  );\n\n  let nextToFocus = newCalendar.querySelector(CALENDAR_PREVIOUS_YEAR_CHUNK);\n  if (nextToFocus.disabled) {\n    nextToFocus = newCalendar.querySelector(CALENDAR_YEAR_PICKER);\n  }\n  nextToFocus.focus();\n};\n\n/**\n * Navigate forward by years and display the year selection screen.\n *\n * @param {HTMLButtonElement} el An element within the date picker component\n */\nconst displayNextYearChunk = (el) => {\n  if (el.disabled) return;\n\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(el);\n  const yearEl = calendarEl.querySelector(CALENDAR_YEAR_FOCUSED);\n  const selectedYear = parseInt(yearEl.textContent, 10);\n\n  let adjustedYear = selectedYear + YEAR_CHUNK;\n  adjustedYear = Math.max(0, adjustedYear);\n\n  const date = setYear(calendarDate, adjustedYear);\n  const cappedDate = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  const newCalendar = displayYearSelection(\n    calendarEl,\n    cappedDate.getFullYear()\n  );\n\n  let nextToFocus = newCalendar.querySelector(CALENDAR_NEXT_YEAR_CHUNK);\n  if (nextToFocus.disabled) {\n    nextToFocus = newCalendar.querySelector(CALENDAR_YEAR_PICKER);\n  }\n  nextToFocus.focus();\n};\n\n/**\n * Select a year in the date picker component.\n *\n * @param {HTMLButtonElement} yearEl A year element within the date picker component\n */\nconst selectYear = (yearEl) => {\n  if (yearEl.disabled) return;\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(yearEl);\n  const selectedYear = parseInt(yearEl.innerHTML, 10);\n  let date = setYear(calendarDate, selectedYear);\n  date = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  const newCalendar = renderCalendar(calendarEl, date);\n  newCalendar.querySelector(CALENDAR_DATE_FOCUSED).focus();\n};\n\n// #endregion Calendar - Year Selection View\n\n// #region Calendar Event Handling\n\n/**\n * Hide the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleEscapeFromCalendar = (event) => {\n  const { datePickerEl, externalInputEl } = getDatePickerContext(event.target);\n\n  hideCalendar(datePickerEl);\n  externalInputEl.focus();\n\n  event.preventDefault();\n};\n\n// #endregion Calendar Event Handling\n\n// #region Calendar Date Event Handling\n\n/**\n * Adjust the date and display the calendar if needed.\n *\n * @param {function} adjustDateFn function that returns the adjusted date\n */\nconst adjustCalendar = (adjustDateFn) => (event) => {\n  const { calendarEl, calendarDate, minDate, maxDate } = getDatePickerContext(\n    event.target\n  );\n\n  const date = adjustDateFn(calendarDate);\n\n  const cappedDate = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  if (!isSameDay(calendarDate, cappedDate)) {\n    const newCalendar = renderCalendar(calendarEl, cappedDate);\n    newCalendar.querySelector(CALENDAR_DATE_FOCUSED).focus();\n  }\n  event.preventDefault();\n};\n\n/**\n * Navigate back one week and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleUpFromDate = adjustCalendar((date) => subWeeks(date, 1));\n\n/**\n * Navigate forward one week and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleDownFromDate = adjustCalendar((date) => addWeeks(date, 1));\n\n/**\n * Navigate back one day and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleLeftFromDate = adjustCalendar((date) => subDays(date, 1));\n\n/**\n * Navigate forward one day and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleRightFromDate = adjustCalendar((date) => addDays(date, 1));\n\n/**\n * Navigate to the start of the week and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleHomeFromDate = adjustCalendar((date) => startOfWeek(date));\n\n/**\n * Navigate to the end of the week and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleEndFromDate = adjustCalendar((date) => endOfWeek(date));\n\n/**\n * Navigate forward one month and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handlePageDownFromDate = adjustCalendar((date) => addMonths(date, 1));\n\n/**\n * Navigate back one month and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handlePageUpFromDate = adjustCalendar((date) => subMonths(date, 1));\n\n/**\n * Navigate forward one year and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleShiftPageDownFromDate = adjustCalendar((date) => addYears(date, 1));\n\n/**\n * Navigate back one year and display the calendar.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleShiftPageUpFromDate = adjustCalendar((date) => subYears(date, 1));\n\n/**\n * display the calendar for the mouseover date.\n *\n * @param {MouseEvent} event The mouseover event\n * @param {HTMLButtonElement} dateEl A date element within the date picker component\n */\nconst handleMouseoverFromDate = (dateEl) => {\n  if (dateEl.disabled) return;\n\n  const calendarEl = dateEl.closest(DATE_PICKER_CALENDAR);\n\n  const currentCalendarDate = calendarEl.dataset.value;\n  const hoverDate = dateEl.dataset.value;\n\n  if (hoverDate === currentCalendarDate) return;\n\n  const dateToDisplay = parseDateString(hoverDate);\n  const newCalendar = renderCalendar(calendarEl, dateToDisplay);\n  newCalendar.querySelector(CALENDAR_DATE_FOCUSED).focus();\n};\n\n// #endregion Calendar Date Event Handling\n\n// #region Calendar Month Event Handling\n\n/**\n * Adjust the month and display the month selection screen if needed.\n *\n * @param {function} adjustMonthFn function that returns the adjusted month\n */\nconst adjustMonthSelectionScreen = (adjustMonthFn) => (event) => {\n  const monthEl = event.target;\n  const selectedMonth = parseInt(monthEl.dataset.value, 10);\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(monthEl);\n  const currentDate = setMonth(calendarDate, selectedMonth);\n\n  let adjustedMonth = adjustMonthFn(selectedMonth);\n  adjustedMonth = Math.max(0, Math.min(11, adjustedMonth));\n\n  const date = setMonth(calendarDate, adjustedMonth);\n  const cappedDate = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  if (!isSameMonth(currentDate, cappedDate)) {\n    const newCalendar = displayMonthSelection(\n      calendarEl,\n      cappedDate.getMonth()\n    );\n    newCalendar.querySelector(CALENDAR_MONTH_FOCUSED).focus();\n  }\n  event.preventDefault();\n};\n\n/**\n * Navigate back three months and display the month selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleUpFromMonth = adjustMonthSelectionScreen((month) => month - 3);\n\n/**\n * Navigate forward three months and display the month selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleDownFromMonth = adjustMonthSelectionScreen((month) => month + 3);\n\n/**\n * Navigate back one month and display the month selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleLeftFromMonth = adjustMonthSelectionScreen((month) => month - 1);\n\n/**\n * Navigate forward one month and display the month selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleRightFromMonth = adjustMonthSelectionScreen((month) => month + 1);\n\n/**\n * Navigate to the start of the row of months and display the month selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleHomeFromMonth = adjustMonthSelectionScreen(\n  (month) => month - (month % 3)\n);\n\n/**\n * Navigate to the end of the row of months and display the month selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleEndFromMonth = adjustMonthSelectionScreen(\n  (month) => month + 2 - (month % 3)\n);\n\n/**\n * Navigate to the last month (December) and display the month selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handlePageDownFromMonth = adjustMonthSelectionScreen(() => 11);\n\n/**\n * Navigate to the first month (January) and display the month selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handlePageUpFromMonth = adjustMonthSelectionScreen(() => 0);\n\n/**\n * update the focus on a month when the mouse moves.\n *\n * @param {MouseEvent} event The mouseover event\n * @param {HTMLButtonElement} monthEl A month element within the date picker component\n */\nconst handleMouseoverFromMonth = (monthEl) => {\n  if (monthEl.disabled) return;\n  if (monthEl.classList.contains(CALENDAR_MONTH_FOCUSED_CLASS)) return;\n\n  const focusMonth = parseInt(monthEl.dataset.value, 10);\n\n  const newCalendar = displayMonthSelection(monthEl, focusMonth);\n  newCalendar.querySelector(CALENDAR_MONTH_FOCUSED).focus();\n};\n\n// #endregion Calendar Month Event Handling\n\n// #region Calendar Year Event Handling\n\n/**\n * Adjust the year and display the year selection screen if needed.\n *\n * @param {function} adjustYearFn function that returns the adjusted year\n */\nconst adjustYearSelectionScreen = (adjustYearFn) => (event) => {\n  const yearEl = event.target;\n  const selectedYear = parseInt(yearEl.dataset.value, 10);\n  const { calendarEl, calendarDate, minDate, maxDate } =\n    getDatePickerContext(yearEl);\n  const currentDate = setYear(calendarDate, selectedYear);\n\n  let adjustedYear = adjustYearFn(selectedYear);\n  adjustedYear = Math.max(0, adjustedYear);\n\n  const date = setYear(calendarDate, adjustedYear);\n  const cappedDate = keepDateBetweenMinAndMax(date, minDate, maxDate);\n  if (!isSameYear(currentDate, cappedDate)) {\n    const newCalendar = displayYearSelection(\n      calendarEl,\n      cappedDate.getFullYear()\n    );\n    newCalendar.querySelector(CALENDAR_YEAR_FOCUSED).focus();\n  }\n  event.preventDefault();\n};\n\n/**\n * Navigate back three years and display the year selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleUpFromYear = adjustYearSelectionScreen((year) => year - 3);\n\n/**\n * Navigate forward three years and display the year selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleDownFromYear = adjustYearSelectionScreen((year) => year + 3);\n\n/**\n * Navigate back one year and display the year selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleLeftFromYear = adjustYearSelectionScreen((year) => year - 1);\n\n/**\n * Navigate forward one year and display the year selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleRightFromYear = adjustYearSelectionScreen((year) => year + 1);\n\n/**\n * Navigate to the start of the row of years and display the year selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleHomeFromYear = adjustYearSelectionScreen(\n  (year) => year - (year % 3)\n);\n\n/**\n * Navigate to the end of the row of years and display the year selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handleEndFromYear = adjustYearSelectionScreen(\n  (year) => year + 2 - (year % 3)\n);\n\n/**\n * Navigate to back 12 years and display the year selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handlePageUpFromYear = adjustYearSelectionScreen(\n  (year) => year - YEAR_CHUNK\n);\n\n/**\n * Navigate forward 12 years and display the year selection screen.\n *\n * @param {KeyboardEvent} event the keydown event\n */\nconst handlePageDownFromYear = adjustYearSelectionScreen(\n  (year) => year + YEAR_CHUNK\n);\n\n/**\n * update the focus on a year when the mouse moves.\n *\n * @param {MouseEvent} event The mouseover event\n * @param {HTMLButtonElement} dateEl A year element within the date picker component\n */\nconst handleMouseoverFromYear = (yearEl) => {\n  if (yearEl.disabled) return;\n  if (yearEl.classList.contains(CALENDAR_YEAR_FOCUSED_CLASS)) return;\n\n  const focusYear = parseInt(yearEl.dataset.value, 10);\n\n  const newCalendar = displayYearSelection(yearEl, focusYear);\n  newCalendar.querySelector(CALENDAR_YEAR_FOCUSED).focus();\n};\n\n// #endregion Calendar Year Event Handling\n\n// #region Focus Handling Event Handling\n\nconst tabHandler = (focusable) => {\n  const getFocusableContext = (el) => {\n    const { calendarEl } = getDatePickerContext(el);\n    const focusableElements = select(focusable, calendarEl);\n\n    const firstTabIndex = 0;\n    const lastTabIndex = focusableElements.length - 1;\n    const firstTabStop = focusableElements[firstTabIndex];\n    const lastTabStop = focusableElements[lastTabIndex];\n    const focusIndex = focusableElements.indexOf(activeElement());\n\n    const isLastTab = focusIndex === lastTabIndex;\n    const isFirstTab = focusIndex === firstTabIndex;\n    const isNotFound = focusIndex === -1;\n\n    return {\n      focusableElements,\n      isNotFound,\n      firstTabStop,\n      isFirstTab,\n      lastTabStop,\n      isLastTab,\n    };\n  };\n\n  return {\n    tabAhead(event) {\n      const { firstTabStop, isLastTab, isNotFound } = getFocusableContext(\n        event.target\n      );\n\n      if (isLastTab || isNotFound) {\n        event.preventDefault();\n        firstTabStop.focus();\n      }\n    },\n    tabBack(event) {\n      const { lastTabStop, isFirstTab, isNotFound } = getFocusableContext(\n        event.target\n      );\n\n      if (isFirstTab || isNotFound) {\n        event.preventDefault();\n        lastTabStop.focus();\n      }\n    },\n  };\n};\n\nconst datePickerTabEventHandler = tabHandler(DATE_PICKER_FOCUSABLE);\nconst monthPickerTabEventHandler = tabHandler(MONTH_PICKER_FOCUSABLE);\nconst yearPickerTabEventHandler = tabHandler(YEAR_PICKER_FOCUSABLE);\n\n// #endregion Focus Handling Event Handling\n\n// #region Date Picker Event Delegation Registration / Component\n\nconst datePickerEvents = {\n  [CLICK]: {\n    [DATE_PICKER_BUTTON]() {\n      toggleCalendar(this);\n    },\n    [CALENDAR_DATE]() {\n      selectDate(this);\n    },\n    [CALENDAR_MONTH]() {\n      selectMonth(this);\n    },\n    [CALENDAR_YEAR]() {\n      selectYear(this);\n    },\n    [CALENDAR_PREVIOUS_MONTH]() {\n      displayPreviousMonth(this);\n    },\n    [CALENDAR_NEXT_MONTH]() {\n      displayNextMonth(this);\n    },\n    [CALENDAR_PREVIOUS_YEAR]() {\n      displayPreviousYear(this);\n    },\n    [CALENDAR_NEXT_YEAR]() {\n      displayNextYear(this);\n    },\n    [CALENDAR_PREVIOUS_YEAR_CHUNK]() {\n      displayPreviousYearChunk(this);\n    },\n    [CALENDAR_NEXT_YEAR_CHUNK]() {\n      displayNextYearChunk(this);\n    },\n    [CALENDAR_MONTH_SELECTION]() {\n      const newCalendar = displayMonthSelection(this);\n      newCalendar.querySelector(CALENDAR_MONTH_FOCUSED).focus();\n    },\n    [CALENDAR_YEAR_SELECTION]() {\n      const newCalendar = displayYearSelection(this);\n      newCalendar.querySelector(CALENDAR_YEAR_FOCUSED).focus();\n    },\n  },\n  keyup: {\n    [DATE_PICKER_CALENDAR](event) {\n      const keydown = this.dataset.keydownKeyCode;\n      if (`${event.keyCode}` !== keydown) {\n        event.preventDefault();\n      }\n    },\n  },\n  keydown: {\n    [DATE_PICKER_EXTERNAL_INPUT](event) {\n      if (event.keyCode === ENTER_KEYCODE) {\n        validateDateInput(this);\n      }\n    },\n    [CALENDAR_DATE]: keymap({\n      Up: handleUpFromDate,\n      ArrowUp: handleUpFromDate,\n      Down: handleDownFromDate,\n      ArrowDown: handleDownFromDate,\n      Left: handleLeftFromDate,\n      ArrowLeft: handleLeftFromDate,\n      Right: handleRightFromDate,\n      ArrowRight: handleRightFromDate,\n      Home: handleHomeFromDate,\n      End: handleEndFromDate,\n      PageDown: handlePageDownFromDate,\n      PageUp: handlePageUpFromDate,\n      \"Shift+PageDown\": handleShiftPageDownFromDate,\n      \"Shift+PageUp\": handleShiftPageUpFromDate,\n      Tab: datePickerTabEventHandler.tabAhead,\n    }),\n    [CALENDAR_DATE_PICKER]: keymap({\n      Tab: datePickerTabEventHandler.tabAhead,\n      \"Shift+Tab\": datePickerTabEventHandler.tabBack,\n    }),\n    [CALENDAR_MONTH]: keymap({\n      Up: handleUpFromMonth,\n      ArrowUp: handleUpFromMonth,\n      Down: handleDownFromMonth,\n      ArrowDown: handleDownFromMonth,\n      Left: handleLeftFromMonth,\n      ArrowLeft: handleLeftFromMonth,\n      Right: handleRightFromMonth,\n      ArrowRight: handleRightFromMonth,\n      Home: handleHomeFromMonth,\n      End: handleEndFromMonth,\n      PageDown: handlePageDownFromMonth,\n      PageUp: handlePageUpFromMonth,\n    }),\n    [CALENDAR_MONTH_PICKER]: keymap({\n      Tab: monthPickerTabEventHandler.tabAhead,\n      \"Shift+Tab\": monthPickerTabEventHandler.tabBack,\n    }),\n    [CALENDAR_YEAR]: keymap({\n      Up: handleUpFromYear,\n      ArrowUp: handleUpFromYear,\n      Down: handleDownFromYear,\n      ArrowDown: handleDownFromYear,\n      Left: handleLeftFromYear,\n      ArrowLeft: handleLeftFromYear,\n      Right: handleRightFromYear,\n      ArrowRight: handleRightFromYear,\n      Home: handleHomeFromYear,\n      End: handleEndFromYear,\n      PageDown: handlePageDownFromYear,\n      PageUp: handlePageUpFromYear,\n    }),\n    [CALENDAR_YEAR_PICKER]: keymap({\n      Tab: yearPickerTabEventHandler.tabAhead,\n      \"Shift+Tab\": yearPickerTabEventHandler.tabBack,\n    }),\n    [DATE_PICKER_CALENDAR](event) {\n      this.dataset.keydownKeyCode = event.keyCode;\n    },\n    [DATE_PICKER](event) {\n      const keyMap = keymap({\n        Escape: handleEscapeFromCalendar,\n      });\n\n      keyMap(event);\n    },\n  },\n  focusout: {\n    [DATE_PICKER_EXTERNAL_INPUT]() {\n      validateDateInput(this);\n    },\n    [DATE_PICKER](event) {\n      if (!this.contains(event.relatedTarget)) {\n        hideCalendar(this);\n      }\n    },\n  },\n  input: {\n    [DATE_PICKER_EXTERNAL_INPUT]() {\n      reconcileInputValues(this);\n      updateCalendarIfVisible(this);\n    },\n  },\n};\n\nif (!isIosDevice()) {\n  datePickerEvents.mouseover = {\n    [CALENDAR_DATE_CURRENT_MONTH]() {\n      handleMouseoverFromDate(this);\n    },\n    [CALENDAR_MONTH]() {\n      handleMouseoverFromMonth(this);\n    },\n    [CALENDAR_YEAR]() {\n      handleMouseoverFromYear(this);\n    },\n  };\n}\n\nconst datePicker = behavior(datePickerEvents, {\n  init(root) {\n    selectOrMatches(DATE_PICKER, root).forEach((datePickerEl) => {\n      enhanceDatePicker(datePickerEl);\n    });\n  },\n  getDatePickerContext,\n  disable,\n  ariaDisable,\n  enable,\n  isDateInputInvalid,\n  setCalendarValue,\n  validateDateInput,\n  renderCalendar,\n  updateCalendarIfVisible,\n});\n\n// #endregion Date Picker Event Delegation Registration / Component\n\nmodule.exports = datePicker;\n","const selectOrMatches = require(\"../../uswds-core/src/js/utils/select-or-matches\");\nconst behavior = require(\"../../uswds-core/src/js/utils/behavior\");\nconst Sanitizer = require(\"../../uswds-core/src/js/utils/sanitizer\");\nconst { prefix: PREFIX } = require(\"../../uswds-core/src/js/config\");\n\nconst DROPZONE_CLASS = `${PREFIX}-file-input`;\nconst DROPZONE = `.${DROPZONE_CLASS}`;\nconst INPUT_CLASS = `${PREFIX}-file-input__input`;\nconst TARGET_CLASS = `${PREFIX}-file-input__target`;\nconst INPUT = `.${INPUT_CLASS}`;\nconst BOX_CLASS = `${PREFIX}-file-input__box`;\nconst INSTRUCTIONS_CLASS = `${PREFIX}-file-input__instructions`;\nconst PREVIEW_CLASS = `${PREFIX}-file-input__preview`;\nconst PREVIEW_HEADING_CLASS = `${PREFIX}-file-input__preview-heading`;\nconst DISABLED_CLASS = `${PREFIX}-file-input--disabled`;\nconst CHOOSE_CLASS = `${PREFIX}-file-input__choose`;\nconst ACCEPTED_FILE_MESSAGE_CLASS = `${PREFIX}-file-input__accepted-files-message`;\nconst DRAG_TEXT_CLASS = `${PREFIX}-file-input__drag-text`;\nconst DRAG_CLASS = `${PREFIX}-file-input--drag`;\nconst LOADING_CLASS = \"is-loading\";\nconst INVALID_FILE_CLASS = \"has-invalid-file\";\nconst GENERIC_PREVIEW_CLASS_NAME = `${PREFIX}-file-input__preview-image`;\nconst GENERIC_PREVIEW_CLASS = `${GENERIC_PREVIEW_CLASS_NAME}--generic`;\nconst PDF_PREVIEW_CLASS = `${GENERIC_PREVIEW_CLASS_NAME}--pdf`;\nconst WORD_PREVIEW_CLASS = `${GENERIC_PREVIEW_CLASS_NAME}--word`;\nconst VIDEO_PREVIEW_CLASS = `${GENERIC_PREVIEW_CLASS_NAME}--video`;\nconst EXCEL_PREVIEW_CLASS = `${GENERIC_PREVIEW_CLASS_NAME}--excel`;\nconst SR_ONLY_CLASS = `${PREFIX}-sr-only`;\nconst SPACER_GIF =\n  \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n\nlet TYPE_IS_VALID = Boolean(true); // logic gate for change listener\nlet DEFAULT_ARIA_LABEL_TEXT = \"\";\nlet DEFAULT_FILE_STATUS_TEXT = \"\";\n\n/**\n * The properties and elements within the file input.\n * @typedef {Object} FileInputContext\n * @property {HTMLDivElement} dropZoneEl\n * @property {HTMLInputElement} inputEl\n */\n\n/**\n * Get an object of the properties and elements belonging directly to the given\n * file input component.\n *\n * @param {HTMLElement} el the element within the file input\n * @returns {FileInputContext} elements\n */\nconst getFileInputContext = (el) => {\n  const dropZoneEl = el.closest(DROPZONE);\n\n  if (!dropZoneEl) {\n    throw new Error(`Element is missing outer ${DROPZONE}`);\n  }\n\n  const inputEl = dropZoneEl.querySelector(INPUT);\n\n  return {\n    dropZoneEl,\n    inputEl,\n  };\n};\n\n/**\n * Disable the file input component\n *\n * @param {HTMLElement} el An element within the file input component\n */\nconst disable = (el) => {\n  const { dropZoneEl, inputEl } = getFileInputContext(el);\n\n  inputEl.disabled = true;\n  dropZoneEl.classList.add(DISABLED_CLASS);\n};\n\n/**\n * Set aria-disabled attribute to file input component\n *\n * @param {HTMLElement} el An element within the file input component\n */\nconst ariaDisable = (el) => {\n  const { dropZoneEl } = getFileInputContext(el);\n\n  dropZoneEl.classList.add(DISABLED_CLASS);\n};\n\n/**\n * Enable the file input component\n *\n * @param {HTMLElement} el An element within the file input component\n */\nconst enable = (el) => {\n  const { dropZoneEl, inputEl } = getFileInputContext(el);\n\n  inputEl.disabled = false;\n  dropZoneEl.classList.remove(DISABLED_CLASS);\n  dropZoneEl.removeAttribute(\"aria-disabled\");\n};\n\n/**\n *\n * @param {String} s special characters\n * @returns {String} replaces specified values\n */\nconst replaceName = (s) => {\n  const c = s.charCodeAt(0);\n  if (c === 32) return \"-\";\n  if (c >= 65 && c <= 90) return `img_${s.toLowerCase()}`;\n  return `__${(\"000\", c.toString(16)).slice(-4)}`;\n};\n\n/**\n * Creates an ID name for each file that strips all invalid characters.\n * @param {String} name - name of the file added to file input (searchvalue)\n * @returns {String} same characters as the name with invalid chars removed (newvalue)\n */\nconst makeSafeForID = (name) => name.replace(/[^a-z0-9]/g, replaceName);\n\n// Takes a generated safe ID and creates a unique ID.\nconst createUniqueID = (name) =>\n  `${name}-${Math.floor(Date.now().toString() / 1000)}`;\n\n/**\n * Determines if the singular or plural item label should be used\n * Determination is based on the presence of the `multiple` attribute\n *\n * @param {HTMLInputElement} fileInputEl - The input element.\n * @returns {HTMLDivElement} The singular or plural version of \"item\"\n */\nconst getItemsLabel = (fileInputEl) => {\n  const acceptsMultiple = fileInputEl.hasAttribute(\"multiple\");\n  const itemsLabel = acceptsMultiple ? \"files\" : \"file\";\n\n  return itemsLabel;\n};\n\n/**\n * Scaffold the file input component with a parent wrapper and\n * Create a target area overlay for drag and drop functionality\n *\n * @param {HTMLInputElement} fileInputEl - The input element.\n * @returns {HTMLDivElement} The drag and drop target area.\n */\nconst createTargetArea = (fileInputEl) => {\n  const fileInputParent = document.createElement(\"div\");\n  const dropTarget = document.createElement(\"div\");\n  const box = document.createElement(\"div\");\n\n  // Adds class names and other attributes\n  fileInputEl.classList.remove(DROPZONE_CLASS);\n  fileInputEl.classList.add(INPUT_CLASS);\n  fileInputParent.classList.add(DROPZONE_CLASS);\n  box.classList.add(BOX_CLASS);\n  dropTarget.classList.add(TARGET_CLASS);\n\n  // Adds child elements to the DOM\n  dropTarget.prepend(box);\n  fileInputEl.parentNode.insertBefore(dropTarget, fileInputEl);\n  fileInputEl.parentNode.insertBefore(fileInputParent, dropTarget);\n  dropTarget.appendChild(fileInputEl);\n  fileInputParent.appendChild(dropTarget);\n\n  return dropTarget;\n};\n\n/**\n * Build the visible element with default interaction instructions.\n *\n * @param {HTMLInputElement} fileInputEl - The input element.\n * @returns {HTMLDivElement} The container for visible interaction instructions.\n */\nconst createVisibleInstructions = (fileInputEl) => {\n  const fileInputParent = fileInputEl.closest(DROPZONE);\n  const itemsLabel = getItemsLabel(fileInputEl);\n  const instructions = document.createElement(\"div\");\n  const dragText = `Drag ${itemsLabel} here or`;\n  const chooseText = \"choose from folder\";\n\n  // Create instructions text for aria-label\n  DEFAULT_ARIA_LABEL_TEXT = `${dragText} ${chooseText}`;\n\n  // Adds class names and other attributes\n  instructions.classList.add(INSTRUCTIONS_CLASS);\n  instructions.setAttribute(\"aria-hidden\", \"true\");\n\n  // Add initial instructions for input usage\n  fileInputEl.setAttribute(\"aria-label\", DEFAULT_ARIA_LABEL_TEXT);\n  instructions.innerHTML = Sanitizer.escapeHTML`<span class=\"${DRAG_TEXT_CLASS}\">${dragText}</span> <span class=\"${CHOOSE_CLASS}\">${chooseText}</span>`;\n\n  // Add the instructions element to the DOM\n  fileInputEl.parentNode.insertBefore(instructions, fileInputEl);\n\n  // IE11 and Edge do not support drop files on file inputs, so we've removed text that indicates that\n  if (\n    /rv:11.0/i.test(navigator.userAgent) ||\n    /Edge\\/\\d./i.test(navigator.userAgent)\n  ) {\n    fileInputParent.querySelector(`.${DRAG_TEXT_CLASS}`).outerHTML = \"\";\n  }\n\n  return instructions;\n};\n\n/**\n * Build a screen reader-only message element that contains file status updates and\n * Create and set the default file status message\n *\n * @param {HTMLInputElement} fileInputEl - The input element.\n */\nconst createSROnlyStatus = (fileInputEl) => {\n  const statusEl = document.createElement(\"div\");\n  const itemsLabel = getItemsLabel(fileInputEl);\n  const fileInputParent = fileInputEl.closest(DROPZONE);\n  const fileInputTarget = fileInputEl.closest(`.${TARGET_CLASS}`);\n\n  DEFAULT_FILE_STATUS_TEXT = `No ${itemsLabel} selected.`;\n\n  // Adds class names and other attributes\n  statusEl.classList.add(SR_ONLY_CLASS);\n  statusEl.setAttribute(\"aria-live\", \"polite\");\n\n  // Add initial file status message\n  statusEl.textContent = DEFAULT_FILE_STATUS_TEXT;\n\n  // Add the status element to the DOM\n  fileInputParent.insertBefore(statusEl, fileInputTarget);\n};\n\n/**\n * Scaffold the component with all required elements\n *\n * @param {HTMLInputElement} fileInputEl - The original input element.\n */\nconst enhanceFileInput = (fileInputEl) => {\n  const isInputDisabled =\n    fileInputEl.hasAttribute(\"aria-disabled\") ||\n    fileInputEl.hasAttribute(\"disabled\");\n  const dropTarget = createTargetArea(fileInputEl);\n  const instructions = createVisibleInstructions(fileInputEl);\n  const { dropZoneEl } = getFileInputContext(fileInputEl);\n\n  if (isInputDisabled) {\n    dropZoneEl.classList.add(DISABLED_CLASS);\n  } else {\n    createSROnlyStatus(fileInputEl);\n  }\n\n  return { instructions, dropTarget };\n};\n\n/**\n * Removes image previews\n * We want to start with a clean list every time files are added to the file input\n *\n * @param {HTMLDivElement} dropTarget - The drag and drop target area.\n * @param {HTMLDivElement} instructions - The container for visible interaction instructions.\n */\nconst removeOldPreviews = (dropTarget, instructions) => {\n  const filePreviews = dropTarget.querySelectorAll(`.${PREVIEW_CLASS}`);\n  const currentPreviewHeading = dropTarget.querySelector(\n    `.${PREVIEW_HEADING_CLASS}`\n  );\n  const currentErrorMessage = dropTarget.querySelector(\n    `.${ACCEPTED_FILE_MESSAGE_CLASS}`\n  );\n\n  /**\n   * finds the parent of the passed node and removes the child\n   * @param {HTMLElement} node\n   */\n  const removeImages = (node) => {\n    node.parentNode.removeChild(node);\n  };\n\n  // Remove the heading above the previews\n  if (currentPreviewHeading) {\n    currentPreviewHeading.outerHTML = \"\";\n  }\n\n  // Remove existing error messages\n  if (currentErrorMessage) {\n    currentErrorMessage.outerHTML = \"\";\n    dropTarget.classList.remove(INVALID_FILE_CLASS);\n  }\n\n  // Get rid of existing previews if they exist, show instructions\n  if (filePreviews !== null) {\n    if (instructions) {\n      instructions.removeAttribute(\"hidden\");\n    }\n    Array.prototype.forEach.call(filePreviews, removeImages);\n  }\n};\n\n/**\n * Update the screen reader-only status message after interaction\n *\n * @param {HTMLDivElement} statusElement - The screen reader-only container for file status updates.\n * @param {Object} fileNames - The selected files found in the fileList object.\n * @param {Array} fileStore - The array of uploaded file names created from the fileNames object.\n */\nconst updateStatusMessage = (statusElement, fileNames, fileStore) => {\n  const statusEl = statusElement;\n  let statusMessage = DEFAULT_FILE_STATUS_TEXT;\n\n  // If files added, update the status message with file name(s)\n  if (fileNames.length === 1) {\n    statusMessage = `You have selected the file: ${fileStore}`;\n  } else if (fileNames.length > 1) {\n    statusMessage = `You have selected ${\n      fileNames.length\n    } files: ${fileStore.join(\", \")}`;\n  }\n\n  // Add delay to encourage screen reader readout\n  setTimeout(() => {\n    statusEl.textContent = statusMessage;\n  }, 1000);\n};\n\n/**\n * Show the preview heading, hide the initial instructions and\n * Update the aria-label with new instructions text\n *\n * @param {HTMLInputElement} fileInputEl - The input element.\n * @param {Object} fileNames - The selected files found in the fileList object.\n */\nconst addPreviewHeading = (fileInputEl, fileNames) => {\n  const filePreviewsHeading = document.createElement(\"div\");\n  const dropTarget = fileInputEl.closest(`.${TARGET_CLASS}`);\n  const instructions = dropTarget.querySelector(`.${INSTRUCTIONS_CLASS}`);\n  let changeItemText = \"Change file\";\n  let previewHeadingText = \"\";\n\n  if (fileNames.length === 1) {\n    previewHeadingText = Sanitizer.escapeHTML`Selected file <span class=\"usa-file-input__choose\">${changeItemText}</span>`;\n  } else if (fileNames.length > 1) {\n    changeItemText = \"Change files\";\n    previewHeadingText = Sanitizer.escapeHTML`${fileNames.length} files selected <span class=\"usa-file-input__choose\">${changeItemText}</span>`;\n  }\n\n  // Hides null state content and sets preview heading\n  instructions.setAttribute(\"hidden\", \"true\");\n  filePreviewsHeading.classList.add(PREVIEW_HEADING_CLASS);\n  filePreviewsHeading.innerHTML = previewHeadingText;\n  dropTarget.insertBefore(filePreviewsHeading, instructions);\n\n  // Update aria label to match the visible action text\n  fileInputEl.setAttribute(\"aria-label\", changeItemText);\n};\n\n/**\n * When new files are applied to file input, this function generates previews\n * and removes old ones.\n *\n * @param {event} e\n * @param {HTMLInputElement} fileInputEl - The input element.\n * @param {HTMLDivElement} instructions - The container for visible interaction instructions.\n * @param {HTMLDivElement} dropTarget - The drag and drop target area.\n */\n\nconst handleChange = (e, fileInputEl, instructions, dropTarget) => {\n  const fileNames = e.target.files;\n  const inputParent = dropTarget.closest(`.${DROPZONE_CLASS}`);\n  const statusElement = inputParent.querySelector(`.${SR_ONLY_CLASS}`);\n  const fileStore = [];\n\n  // First, get rid of existing previews\n  removeOldPreviews(dropTarget, instructions);\n\n  // Then, iterate through files list and create previews\n  for (let i = 0; i < fileNames.length; i += 1) {\n    const reader = new FileReader();\n    const fileName = fileNames[i].name;\n    let imageId;\n\n    // Push updated file names into the store array\n    fileStore.push(fileName);\n\n    // Starts with a loading image while preview is created\n    reader.onloadstart = function createLoadingImage() {\n      imageId = createUniqueID(makeSafeForID(fileName));\n\n      instructions.insertAdjacentHTML(\n        \"afterend\",\n        Sanitizer.escapeHTML`<div class=\"${PREVIEW_CLASS}\" aria-hidden=\"true\">\n          <img id=\"${imageId}\" src=\"${SPACER_GIF}\" alt=\"\" class=\"${GENERIC_PREVIEW_CLASS_NAME} ${LOADING_CLASS}\"/>${fileName}\n        <div>`\n      );\n    };\n\n    // Not all files will be able to generate previews. In case this happens, we provide several types \"generic previews\" based on the file extension.\n    reader.onloadend = function createFilePreview() {\n      const previewImage = document.getElementById(imageId);\n      if (fileName.indexOf(\".pdf\") > 0) {\n        previewImage.setAttribute(\n          \"onerror\",\n          `this.onerror=null;this.src=\"${SPACER_GIF}\"; this.classList.add(\"${PDF_PREVIEW_CLASS}\")`\n        );\n      } else if (\n        fileName.indexOf(\".doc\") > 0 ||\n        fileName.indexOf(\".pages\") > 0\n      ) {\n        previewImage.setAttribute(\n          \"onerror\",\n          `this.onerror=null;this.src=\"${SPACER_GIF}\"; this.classList.add(\"${WORD_PREVIEW_CLASS}\")`\n        );\n      } else if (\n        fileName.indexOf(\".xls\") > 0 ||\n        fileName.indexOf(\".numbers\") > 0\n      ) {\n        previewImage.setAttribute(\n          \"onerror\",\n          `this.onerror=null;this.src=\"${SPACER_GIF}\"; this.classList.add(\"${EXCEL_PREVIEW_CLASS}\")`\n        );\n      } else if (fileName.indexOf(\".mov\") > 0 || fileName.indexOf(\".mp4\") > 0) {\n        previewImage.setAttribute(\n          \"onerror\",\n          `this.onerror=null;this.src=\"${SPACER_GIF}\"; this.classList.add(\"${VIDEO_PREVIEW_CLASS}\")`\n        );\n      } else {\n        previewImage.setAttribute(\n          \"onerror\",\n          `this.onerror=null;this.src=\"${SPACER_GIF}\"; this.classList.add(\"${GENERIC_PREVIEW_CLASS}\")`\n        );\n      }\n\n      // Removes loader and displays preview\n      previewImage.classList.remove(LOADING_CLASS);\n      previewImage.src = reader.result;\n    };\n\n    if (fileNames[i]) {\n      reader.readAsDataURL(fileNames[i]);\n    }\n  }\n\n  if (fileNames.length === 0) {\n    // Reset input aria-label with default message\n    fileInputEl.setAttribute(\"aria-label\", DEFAULT_ARIA_LABEL_TEXT);\n  } else {\n    addPreviewHeading(fileInputEl, fileNames);\n  }\n\n  updateStatusMessage(statusElement, fileNames, fileStore);\n};\n\n/**\n * When using an Accept attribute, invalid files will be hidden from\n * file browser, but they can still be dragged to the input. This\n * function prevents them from being dragged and removes error states\n * when correct files are added.\n *\n * @param {event} e\n * @param {HTMLInputElement} fileInputEl - The input element.\n * @param {HTMLDivElement} instructions - The container for visible interaction instructions.\n * @param {HTMLDivElement} dropTarget - The drag and drop target area.\n */\nconst preventInvalidFiles = (e, fileInputEl, instructions, dropTarget) => {\n  const acceptedFilesAttr = fileInputEl.getAttribute(\"accept\");\n  dropTarget.classList.remove(INVALID_FILE_CLASS);\n\n  /**\n   * We can probably move away from this once IE11 support stops, and replace\n   * with a simple es `.includes`\n   * check if element is in array\n   * check if 1 or more alphabets are in string\n   * if element is present return the position value and -1 otherwise\n   * @param {Object} file\n   * @param {String} value\n   * @returns {Boolean}\n   */\n  const isIncluded = (file, value) => {\n    let returnValue = false;\n    const pos = file.indexOf(value);\n    if (pos >= 0) {\n      returnValue = true;\n    }\n    return returnValue;\n  };\n\n  // Runs if only specific files are accepted\n  if (acceptedFilesAttr) {\n    const acceptedFiles = acceptedFilesAttr.split(\",\");\n    const errorMessage = document.createElement(\"div\");\n\n    // If multiple files are dragged, this iterates through them and look for any files that are not accepted.\n    let allFilesAllowed = true;\n    const scannedFiles = e.target.files || e.dataTransfer.files;\n    for (let i = 0; i < scannedFiles.length; i += 1) {\n      const file = scannedFiles[i];\n      if (allFilesAllowed) {\n        for (let j = 0; j < acceptedFiles.length; j += 1) {\n          const fileType = acceptedFiles[j];\n          allFilesAllowed =\n            file.name.indexOf(fileType) > 0 ||\n            isIncluded(file.type, fileType.replace(/\\*/g, \"\"));\n          if (allFilesAllowed) {\n            TYPE_IS_VALID = true;\n            break;\n          }\n        }\n      } else break;\n    }\n\n    // If dragged files are not accepted, this removes them from the value of the input and creates and error state\n    if (!allFilesAllowed) {\n      removeOldPreviews(dropTarget, instructions);\n      fileInputEl.value = \"\"; // eslint-disable-line no-param-reassign\n      dropTarget.insertBefore(errorMessage, fileInputEl);\n      errorMessage.textContent =\n        fileInputEl.dataset.errormessage || `This is not a valid file type.`;\n      errorMessage.classList.add(ACCEPTED_FILE_MESSAGE_CLASS);\n      dropTarget.classList.add(INVALID_FILE_CLASS);\n      TYPE_IS_VALID = false;\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n};\n\n/**\n * 1. passes through gate for preventing invalid files\n * 2. handles updates if file is valid\n *\n * @param {event} event\n * @param {HTMLInputElement} fileInputEl - The input element.\n * @param {HTMLDivElement} instructions - The container for visible interaction instructions.\n * @param {HTMLDivElement} dropTarget - The drag and drop target area.\n */\nconst handleUpload = (event, fileInputEl, instructions, dropTarget) => {\n  preventInvalidFiles(event, fileInputEl, instructions, dropTarget);\n  if (TYPE_IS_VALID === true) {\n    handleChange(event, fileInputEl, instructions, dropTarget);\n  }\n};\n\nconst fileInput = behavior(\n  {},\n  {\n    init(root) {\n      selectOrMatches(DROPZONE, root).forEach((fileInputEl) => {\n        const { instructions, dropTarget } = enhanceFileInput(fileInputEl);\n\n        dropTarget.addEventListener(\n          \"dragover\",\n          function handleDragOver() {\n            this.classList.add(DRAG_CLASS);\n          },\n          false\n        );\n\n        dropTarget.addEventListener(\n          \"dragleave\",\n          function handleDragLeave() {\n            this.classList.remove(DRAG_CLASS);\n          },\n          false\n        );\n\n        dropTarget.addEventListener(\n          \"drop\",\n          function handleDrop() {\n            this.classList.remove(DRAG_CLASS);\n          },\n          false\n        );\n\n        fileInputEl.addEventListener(\n          \"change\",\n          (e) => handleUpload(e, fileInputEl, instructions, dropTarget),\n          false\n        );\n      });\n    },\n    teardown(root) {\n      selectOrMatches(INPUT, root).forEach((fileInputEl) => {\n        const fileInputTopElement = fileInputEl.parentElement.parentElement;\n        fileInputTopElement.parentElement.replaceChild(\n          fileInputEl,\n          fileInputTopElement\n        );\n        // eslint-disable-next-line no-param-reassign\n        fileInputEl.className = DROPZONE_CLASS;\n      });\n    },\n    getFileInputContext,\n    disable,\n    ariaDisable,\n    enable,\n  }\n);\n\nmodule.exports = fileInput;\n","const select = require(\"../../uswds-core/src/js/utils/select\");\nconst behavior = require(\"../../uswds-core/src/js/utils/behavior\");\nconst { CLICK } = require(\"../../uswds-core/src/js/events\");\nconst { prefix: PREFIX } = require(\"../../uswds-core/src/js/config\");\nconst Sanitizer = require(\"../../uswds-core/src/js/utils/sanitizer\");\n\nconst TABLE = `.${PREFIX}-table`;\nconst SORTED = \"aria-sort\";\nconst ASCENDING = \"ascending\";\nconst DESCENDING = \"descending\";\nconst SORT_OVERRIDE = \"data-sort-value\";\nconst SORT_BUTTON_CLASS = `${PREFIX}-table__header__button`;\nconst SORT_BUTTON = `.${SORT_BUTTON_CLASS}`;\nconst SORTABLE_HEADER = `th[data-sortable]`;\nconst ANNOUNCEMENT_REGION = `.${PREFIX}-table__announcement-region[aria-live=\"polite\"]`;\n\n/** Gets the data-sort-value attribute value, if provided — otherwise, gets\n * the innerText or textContent — of the child element (HTMLTableCellElement)\n * at the specified index of the given table row\n *\n * @param {number} index\n * @param {array<HTMLTableRowElement>} tr\n * @return {boolean}\n */\nconst getCellValue = (tr, index) =>\n  tr.children[index].getAttribute(SORT_OVERRIDE) ||\n  tr.children[index].innerText ||\n  tr.children[index].textContent;\n\n/**\n * Compares the values of two row array items at the given index, then sorts by the given direction\n * @param {number} index\n * @param {string} direction\n * @return {boolean}\n */\nconst compareFunction = (index, isAscending) => (thisRow, nextRow) => {\n  // get values to compare from data attribute or cell content\n  const value1 = getCellValue(isAscending ? thisRow : nextRow, index);\n  const value2 = getCellValue(isAscending ? nextRow : thisRow, index);\n\n  // if neither value is empty, and if both values are already numbers, compare numerically\n  if (\n    value1 &&\n    value2 &&\n    !Number.isNaN(Number(value1)) &&\n    !Number.isNaN(Number(value2))\n  ) {\n    return value1 - value2;\n  }\n  // Otherwise, compare alphabetically based on current user locale\n  return value1.toString().localeCompare(value2, navigator.language, {\n    numeric: true,\n    ignorePunctuation: true,\n  });\n};\n\n/**\n * Get an Array of column headers elements belonging directly to the given\n * table element.\n * @param {HTMLTableElement} table\n * @return {array<HTMLTableHeaderCellElement>}\n */\nconst getColumnHeaders = (table) => {\n  const headers = select(SORTABLE_HEADER, table);\n  return headers.filter((header) => header.closest(TABLE) === table);\n};\n\n/**\n * Update the button label within the given header element, resetting it\n * to the default state (ready to sort ascending) if it's no longer sorted\n * @param {HTMLTableHeaderCellElement} header\n */\nconst updateSortLabel = (header) => {\n  const headerName = header.innerText;\n  const sortedAscending = header.getAttribute(SORTED) === ASCENDING;\n  const isSorted =\n    header.getAttribute(SORTED) === ASCENDING ||\n    header.getAttribute(SORTED) === DESCENDING ||\n    false;\n  const headerLabel = `${headerName}, sortable column, currently ${\n    isSorted\n      ? `${sortedAscending ? `sorted ${ASCENDING}` : `sorted ${DESCENDING}`}`\n      : \"unsorted\"\n  }`;\n  const headerButtonLabel = `Click to sort by ${headerName} in ${\n    sortedAscending ? DESCENDING : ASCENDING\n  } order.`;\n  header.setAttribute(\"aria-label\", headerLabel);\n  header.querySelector(SORT_BUTTON).setAttribute(\"title\", headerButtonLabel);\n};\n\n/**\n * Remove the aria-sort attribute on the given header element, and reset the label and button icon\n * @param {HTMLTableHeaderCellElement} header\n */\nconst unsetSort = (header) => {\n  header.removeAttribute(SORTED);\n  updateSortLabel(header);\n};\n\n/**\n * Sort rows either ascending or descending, based on a given header's aria-sort attribute\n * @param {HTMLTableHeaderCellElement} header\n * @param {boolean} isAscending\n * @return {boolean} true\n */\nconst sortRows = (header, isAscending) => {\n  header.setAttribute(SORTED, isAscending === true ? DESCENDING : ASCENDING);\n  updateSortLabel(header);\n\n  const tbody = header.closest(TABLE).querySelector(\"tbody\");\n\n  // We can use Array.from() and Array.sort() instead once we drop IE11 support, likely in the summer of 2021\n  //\n  // Array.from(tbody.querySelectorAll('tr').sort(\n  //   compareFunction(\n  //     Array.from(header.parentNode.children).indexOf(header),\n  //     !isAscending)\n  //   )\n  // .forEach(tr => tbody.appendChild(tr) );\n\n  // [].slice.call() turns array-like sets into true arrays so that we can sort them\n  const allRows = [].slice.call(tbody.querySelectorAll(\"tr\"));\n  const allHeaders = [].slice.call(header.parentNode.children);\n  const thisHeaderIndex = allHeaders.indexOf(header);\n  allRows.sort(compareFunction(thisHeaderIndex, !isAscending)).forEach((tr) => {\n    [].slice\n      .call(tr.children)\n      .forEach((td) => td.removeAttribute(\"data-sort-active\"));\n    tr.children[thisHeaderIndex].setAttribute(\"data-sort-active\", true);\n    tbody.appendChild(tr);\n  });\n\n  return true;\n};\n\n/**\n * Update the live region immediately following the table whenever sort changes.\n * @param {HTMLTableElement} table\n * @param {HTMLTableHeaderCellElement} sortedHeader\n */\n\nconst updateLiveRegion = (table, sortedHeader) => {\n  const caption = table.querySelector(\"caption\").innerText;\n  const sortedAscending = sortedHeader.getAttribute(SORTED) === ASCENDING;\n  const headerLabel = sortedHeader.innerText;\n  const liveRegion = table.nextElementSibling;\n  if (liveRegion && liveRegion.matches(ANNOUNCEMENT_REGION)) {\n    const sortAnnouncement = `The table named \"${caption}\" is now sorted by ${headerLabel} in ${\n      sortedAscending ? ASCENDING : DESCENDING\n    } order.`;\n    liveRegion.innerText = sortAnnouncement;\n  } else {\n    throw new Error(\n      `Table containing a sortable column header is not followed by an aria-live region.`\n    );\n  }\n};\n\n/**\n * Toggle a header's sort state, optionally providing a target\n * state.\n *\n * @param {HTMLTableHeaderCellElement} header\n * @param {boolean?} isAscending If no state is provided, the current\n * state will be toggled (from false to true, and vice-versa).\n */\nconst toggleSort = (header, isAscending) => {\n  const table = header.closest(TABLE);\n  let safeAscending = isAscending;\n  if (typeof safeAscending !== \"boolean\") {\n    safeAscending = header.getAttribute(SORTED) === ASCENDING;\n  }\n\n  if (!table) {\n    throw new Error(`${SORTABLE_HEADER} is missing outer ${TABLE}`);\n  }\n\n  safeAscending = sortRows(header, isAscending);\n\n  if (safeAscending) {\n    getColumnHeaders(table).forEach((otherHeader) => {\n      if (otherHeader !== header) {\n        unsetSort(otherHeader);\n      }\n    });\n    updateLiveRegion(table, header);\n  }\n};\n\n/**\n ** Inserts a button with icon inside a sortable header\n * @param {HTMLTableHeaderCellElement} header\n */\n\nconst createHeaderButton = (header) => {\n  const buttonEl = document.createElement(\"button\");\n  buttonEl.setAttribute(\"tabindex\", \"0\");\n  buttonEl.classList.add(SORT_BUTTON_CLASS);\n  // ICON_SOURCE\n  buttonEl.innerHTML = Sanitizer.escapeHTML`\n  <svg class=\"${PREFIX}-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n    <g class=\"descending\" fill=\"transparent\">\n      <path d=\"M17 17L15.59 15.59L12.9999 18.17V2H10.9999V18.17L8.41 15.58L7 17L11.9999 22L17 17Z\" />\n    </g>\n    <g class=\"ascending\" fill=\"transparent\">\n      <path transform=\"rotate(180, 12, 12)\" d=\"M17 17L15.59 15.59L12.9999 18.17V2H10.9999V18.17L8.41 15.58L7 17L11.9999 22L17 17Z\" />\n    </g>\n    <g class=\"unsorted\" fill=\"transparent\">\n      <polygon points=\"15.17 15 13 17.17 13 6.83 15.17 9 16.58 7.59 12 3 7.41 7.59 8.83 9 11 6.83 11 17.17 8.83 15 7.42 16.41 12 21 16.59 16.41 15.17 15\"/>\n    </g>\n  </svg>\n  `;\n  header.appendChild(buttonEl);\n  updateSortLabel(header);\n};\n\nconst table = behavior(\n  {\n    [CLICK]: {\n      [SORT_BUTTON](event) {\n        event.preventDefault();\n        toggleSort(\n          event.target.closest(SORTABLE_HEADER),\n          event.target.closest(SORTABLE_HEADER).getAttribute(SORTED) ===\n            ASCENDING\n        );\n      },\n    },\n  },\n  {\n    init(root) {\n      const sortableHeaders = select(SORTABLE_HEADER, root);\n      sortableHeaders.forEach((header) => createHeaderButton(header));\n\n      const firstSorted = sortableHeaders.filter(\n        (header) =>\n          header.getAttribute(SORTED) === ASCENDING ||\n          header.getAttribute(SORTED) === DESCENDING\n      )[0];\n      if (typeof firstSorted === \"undefined\") {\n        // no sortable headers found\n        return;\n      }\n      const sortDir = firstSorted.getAttribute(SORTED);\n      if (sortDir === ASCENDING) {\n        toggleSort(firstSorted, true);\n      } else if (sortDir === DESCENDING) {\n        toggleSort(firstSorted, false);\n      }\n    },\n    TABLE,\n    SORTABLE_HEADER,\n    SORT_BUTTON,\n  }\n);\n\nmodule.exports = table;\n"],"names":[],"sourceRoot":""}